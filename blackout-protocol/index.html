<!DOCTYPE html>
<html lang="en">
<head>
  <base href="/blackout-protocol/">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Blackout Protocol — Sprite PNGs</title>
  <style>
    :root { --frame-w: 960px; }
    html,body{margin:0;background:#000;color:#cfd6df;font-family:monospace;overflow:hidden;}
    #gameContainer{position:relative;width:100%;max-width:var(--frame-w);margin:0 auto;aspect-ratio:4/3;background:#000;border:2px solid #5c5c5c;}
    canvas{position:absolute;inset:0;display:block;image-rendering:pixelated;image-rendering:crisp-edges;}
    #overlayCanvas{pointer-events:none;}
    #resetBtn{position:absolute;left:50%;top:50%;transform:translate(-50%,-8px);padding:10px 16px;background:#0f1016;border:2px solid #626a78;border-radius:6px;color:#cfd6df;letter-spacing:.6px;display:none;cursor:pointer;z-index:5}
    #resetBtn:hover{filter:brightness(1.15)}
  </style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <canvas id="overlayCanvas"></canvas>
  <button id="resetBtn" type="button">Reset (R)</button>
</div>

<script>
/* ================= CONFIG ================= */
const SHOP_URL = './game-shop.html';
const LEVEL_LEN = 1600;
const DOOR_W = 24, DOOR_H = 32;
const HYPER_RELOAD_TAG = 'rev=' + Date.now();

/* ================= CORE / DISPLAY ================= */
let READY=false, LOAD_MSG='Loading…';
addEventListener('error', e => console.error('Runtime error:', e.message));

const VW=256, VH=240, TILE=16;

const gameCanvas=document.getElementById('gameCanvas');
const overlayCanvas=document.getElementById('overlayCanvas');
const gctx=gameCanvas.getContext('2d'); gctx.imageSmoothingEnabled=false;
const octx=overlayCanvas.getContext('2d');

const nes=document.createElement('canvas'); nes.width=VW; nes.height=VH;
const ctx=nes.getContext('2d',{alpha:false});
ctx.imageSmoothingEnabled=false;
ctx.font='9px monospace';
ctx.textBaseline='top';

let RENDER={scale:1,ox:0,oy:0};
function fit(){
  const r=document.getElementById('gameContainer').getBoundingClientRect();
  gameCanvas.width=r.width; gameCanvas.height=r.height;
  overlayCanvas.width=r.width; overlayCanvas.height=r.height;
}
addEventListener('resize',fit); fit();

addEventListener('keydown',e=>{
  if(['Space','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.code)) e.preventDefault();
},{passive:false});

/* ================= ASSETS ================= */
const IMG = (path) => new Promise(resolve=>{
  if(!path){ resolve(null); return; }
  const i=new Image();
  i.onload=()=>{ console.log('✓ Asset loaded successfully:', path); resolve(i); };
  i.onerror=()=>{ console.error('✗ Failed to load asset:', path); resolve(null); };
  i.src=path;
});

/* Sprite + static art definitions */
const SPRITE_DEF={
  player:{fw:48,fh:48, states:{
    idle:'assets/player_idle_48.png', walk:'assets/player_walk_48.png', run:'assets/player_run_48.png',
    jump:'assets/player_jump_48.png', fall:'assets/player_fall_48.png', hurt:'assets/player_hurt_48.png', dead:'assets/player_dead_48.png'
  }, fps:{idle:6, walk:10, run:12, jump:10, fall:10, hurt:6, dead:8}},
  robot:{fw:48,fh:48, states:{
    idle:'assets/robot_idle_48.png', walk:'assets/robot_walk_48.png', run:'assets/robot_run_48.png',
    attack:'assets/robot_attack_48.png', hurt:'assets/robot_hurt_48.png', dead:'assets/robot_dead_48.png'
  }, fps:{idle:6, walk:9, run:10, attack:12, hurt:6, dead:8}},
  drone:{fw:32,fh:32, states:{
    idle:'assets/drone_idle_32.png', hover:'assets/drone_hover_32.png', move:'assets/drone_move_32.png',
    attack:'assets/drone_attack_32.png', hurt:'assets/drone_hurt_32.png', dead:'assets/drone_dead_32.png'
  }, fps:{idle:3, hover:10, move:10, attack:12, hurt:6, dead:8}},
  bg_far:`assets/01_bg_far.png?${HYPER_RELOAD_TAG}`,
  bg_near:`assets/01_bg_near.png?${HYPER_RELOAD_TAG}`,
  coin:`assets/btc_glow.png?${HYPER_RELOAD_TAG}`,
  door:`assets/shop_door_neon.png?${HYPER_RELOAD_TAG}`,
  ledge:`assets/ledge_tile.png?${HYPER_RELOAD_TAG}`,
  platform:`assets/platform_industrial.png?${HYPER_RELOAD_TAG}`,
  terminal:'' // no base terminal; we use animated frames below
};

/* ===== Graphic Ads (your PNGs) — without repeats until deck is used ===== */
const AD_SRC = {
  fourk: `assets/4K.png?${HYPER_RELOAD_TAG}`,
  meat:  `assets/Meat.png?${HYPER_RELOAD_TAG}`,
  holo:  `assets/HoloCompanion.png?${HYPER_RELOAD_TAG}`,
  rent:  `assets/Rent.png?${HYPER_RELOAD_TAG}`,
  drinkA:`assets/Drink_Oil_01.png?${HYPER_RELOAD_TAG}`,
  drinkB:`assets/Drink_Oil_02.png?${HYPER_RELOAD_TAG}`
};
const AD_KINDS = ['fourk','meat','holo','rent','drink'];
let adDeck=[];
function refillDeck(){ adDeck=[...AD_KINDS].sort(()=>Math.random()-0.5); }
function nextAdKind(){ if(!adDeck.length) refillDeck(); return adDeck.shift(); }
refillDeck();

const AdImages = { fourk:null, meat:null, holo:null, rent:null, drink:[null,null] };
async function loadAdImages(){
  AdImages.fourk = await IMG(AD_SRC.fourk);
  AdImages.meat  = await IMG(AD_SRC.meat);
  AdImages.holo  = await IMG(AD_SRC.holo);
  AdImages.rent  = await IMG(AD_SRC.rent);
  AdImages.drink = [ await IMG(AD_SRC.drinkA), await IMG(AD_SRC.drinkB) ];
}

/* Animator helper */
function makeAnimator(sheet, fw, fh, fps){
  const frames = sheet ? Math.max(1, Math.floor(sheet.width / fw)) : 1;
  let frame=0, time=0, spf=1000/(fps||8);
  return {
    reset(){ frame=0; time=0; },
    step(dt, clamp=false){ time+=dt; while(time>spf){ time-=spf; frame = clamp ? Math.min(frame+1, frames-1) : (frame+1)%frames; } },
    draw(x,y,flip=false,alpha=1){
      if(!sheet) return;
      const sx=frame*fw, sy=0;
      ctx.save(); ctx.globalAlpha=alpha;
      if(flip){ ctx.translate(x+fw,y); ctx.scale(-1,1); ctx.drawImage(sheet,sx,sy,fw,fh,0,0,fw,fh); }
      else    { ctx.drawImage(sheet,sx,sy,fw,fh,x,y,fw,fh); }
      ctx.restore();
    },
    frames
  };
}

/* ================= PARALLAX ================= */
const BG={far:null, near:null};
const PARALLAX={far:0.18, near:0.55};
const NEAR_FADE_PX=120;

async function loadBackgrounds(){
  console.log('Loading backgrounds...', {far: SPRITE_DEF.bg_far, near: SPRITE_DEF.bg_near});
  BG.far  = await IMG(SPRITE_DEF.bg_far);
  BG.near = await IMG(SPRITE_DEF.bg_near);
  console.log('BG loaded:', {far: BG.far?.naturalWidth||0, near: BG.near?.naturalWidth||0});
}

// Scale to VH only, tile horizontally, flip every tile to avoid obvious seams
function tileParallax(img, speed){
  if(!img) return;
  const scale = VH / img.height;
  const tileW = Math.max(1, Math.round(img.width * scale));
  const cam = cameraX||0;
  let x = -Math.floor((cam*speed) % tileW);
  if (x>0) x -= tileW;
  for(let i=0;i<4;i++){
    const drawX = x + i*tileW;
    const flip = (i%2)===1;
    ctx.save();
    if(flip){
      ctx.translate(drawX + tileW, 0);
      ctx.scale(-1,1);
      ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, tileW, VH);
    }else{
      ctx.drawImage(img, 0, 0, img.width, img.height, drawX, 0, tileW, VH);
    }
    ctx.restore();
  }
}
function drawBackgrounds(){
  if(!BG.far && !BG.near){ drawSky(); return; }
  if(BG.far)  tileParallax(BG.far,  PARALLAX.far);
  if(BG.near){
    ctx.save();
    tileParallax(BG.near, PARALLAX.near);
    const fadeH=Math.min(NEAR_FADE_PX,VH);
    const g=ctx.createLinearGradient(0,0,0,fadeH);
    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,1)');
    ctx.globalCompositeOperation='destination-in';
    ctx.fillStyle=g; ctx.fillRect(0,0,VW,VH);
    ctx.restore();
  }
}
function drawSky(){
  for(let y=0;y<VH;y++){ const t=y/VH; ctx.fillStyle=`rgb(${12+18*t|0},${16+30*t|0},${30+58*t|0})`; ctx.fillRect(0,y,VH,1); }
}

/* ================= SPRITES ================= */
async function loadSprites(def){
  const out={};
  for(const who of ['player','robot','drone']){
    const fw=def[who].fw, fh=def[who].fh;
    const pack={fw,fh,anim:{}};
    for(const [state,src] of Object.entries(def[who].states)){
      const img=await IMG(src);
      pack.anim[state]={img, make:()=>makeAnimator(img,fw,fh, def[who].fps[state]||8)};
    }
    out[who]=pack;
  }
  return out;
}

/* ================= STATE / INPUT / CAMERA ================= */
let gameState='loading', score=0, btc=0, level=1, justLeveled=0;
let cameraX=0, worldMaxX=0;
const CHUNK=320;

// camera follows earlier so parallax is more visible
const DEAD_ZONE=8;
function updateCamera(){
  const center=VW*0.40; // keep player slightly left of center
  const L=center-DEAD_ZONE, R=center+DEAD_ZONE;
  let target=cameraX;
  if(player.x-cameraX<L) target=player.x-L;
  else if(player.x-cameraX>R) target=player.x-R;
  cameraX += (target-cameraX)*0.45;
  cameraX=Math.max(0,Math.min(cameraX, worldMaxX-VW));
}

const keys={}, JUMP_BUFFER=140, COYOTE=140;
let jumpBufferUntil=0, coyoteUntil=0, jumpHeld=false;
addEventListener('keydown',e=>{
  keys[e.code]=true;
  if(e.code==='Escape') gameState=(gameState==='playing')?'paused':(gameState==='paused'?'playing':gameState);
  if(e.code==='Space'){ jumpBufferUntil=performance.now()+JUMP_BUFFER; jumpHeld=true; }
  if(e.code==='KeyR' && (gameState==='gameOver'||gameState==='levelComplete')) reset();
  if(e.code==='Enter' && gameState==='playing') tryHack();
});
addEventListener('keyup',e=>{ keys[e.code]=false; if(e.code==='Space') jumpHeld=false; });

/* ================= ENTITIES ================= */
let SPR=null;
let player, robots=[], drones=[], platforms=[], terminals=[], ads=[], coins=[];
let exitDoor=null;
const resetBtn=document.getElementById('resetBtn'); resetBtn.onclick=()=>reset();

function makePlayer(){
  const savedHealth = parseInt(localStorage.getItem('playerHealth')) || 100;
  const savedUpgrades = JSON.parse(localStorage.getItem('playerUpgrades')) || {};
  const baseSpeed = 1.52;
  const baseJump  = 5.6;
  const speed = savedUpgrades.speedBoost ? baseSpeed * 1.3 : baseSpeed;
  const jump  = savedUpgrades.jumpBoost  ? baseJump  * 1.2 : baseJump;
  return { x:32, y:VH-80, w:18, h:28, vx:0, vy:0, onGround:false, facing:1,
           speed, aGround:.19, aAir:.12, dragG:.82, dragA:.986, jump,
           hp:savedHealth, dist:0, hitUntil:0, anim:{state:'idle',runner:null},
           upgrades: savedUpgrades };
}

function setAnim(actor, who, state, clamp=false){
  if(actor.anim.state===state) return;
  actor.anim.state=state;
  const spec=SPR[who]?.anim?.[state];
  actor.anim.runner = spec ? spec.make() : null;
  if(actor.anim.runner) actor.anim.runner.reset();
  actor.anim.clamp=clamp;
}
function stepAnim(a,dt){ if(a.anim.runner) a.anim.runner.step(dt, a.anim.clamp); }
function drawAnim(a,who,x,y,flip=false,alpha=1){ const run=a.anim.runner; if(run) run.draw(x,y,flip,alpha); }

/* ================= WORLD GEN ================= */
const choice = a => a[(Math.random()*a.length)|0];
let generatedUntil=0;
const groundY = () => VH-TILE;

function genChunk(startX){
  const endX=startX+CHUNK;
  const firstScreen = startX < VW;

  // ground tiles
  for(let x=startX;x<endX;x+=TILE) platforms.push({x,y:groundY(),w:TILE,h:TILE});

  if(!firstScreen){
    // one guaranteed climbable pair; keeps at most 2 visible
    const LOW_LEDGE_OFFSET  = TILE*3;
    const HIGH_LEDGE_OFFSET = TILE*5;

    const baseX = startX + 50 + Math.random()*(CHUNK-140);
    const lowX  = Math.max(startX+24, Math.min(endX-110, (baseX/TILE|0)*TILE));
    const highX = Math.min(endX-60, lowX + TILE*(5 + ((Math.random()*2)|0)));

    const lowW  = TILE*(5 + ((Math.random()*2)|0));
    const highW = TILE*(4 + ((Math.random()*2)|0));

    const lowY  = groundY() - LOW_LEDGE_OFFSET;
    const highY = groundY() - HIGH_LEDGE_OFFSET;

    platforms.push({x:lowX,  y:lowY,  w:lowW,  h:TILE});
    platforms.push({x:highX, y:highY, w:highW, h:TILE});

    // coins anchored above ledges
    const above = [
      {x: lowX + 8 + Math.random()*(Math.max(16, lowW-16)),  y: lowY-20},
      {x: highX + 8 + Math.random()*(Math.max(16, highW-16)), y: highY-20},
      {x: (lowX+highX)/2, y: Math.min(lowY, highY)-26}
    ];
    for(const p of above){ coins.push({x:p.x|0, y:Math.max(40,Math.min(VH-24,p.y))|0, r:10, taken:false}); }

    // terminals
    if(Math.random()<.5){
      const tx=startX+40+Math.random()*(CHUNK-80); let ty=VH-TILE*2;
      for(const p of platforms){ if(tx>=p.x-4 && tx<=p.x+p.w+4) ty=Math.min(ty,p.y-TILE); }
      terminals.push({x:tx|0,y:ty|0,w:12,h:16,cooldown:0});
    }

    // ads (no repeats until deck is used)
    const ax=startX+60+Math.random()*(CHUNK-120), ay=VH-(120+((Math.random()*50)|0));
    ads.push({x:ax|0,y:ay|0,kind:nextAdKind(),phase:Math.random()*6});

    // enemies
    const rc=1+((Math.random()*2)|0);
    for(let i=0;i<rc;i++){
      const rx=startX+64+Math.random()*(CHUNK-128);
      robots.push({
        x:rx|0,y:VH-TILE*2,w:18,h:24,
        dir:Math.random()<.5?-1:1,speed:.66,hp:3,
        active:false,hitUntil:0,
        state:'patrol', alert:false,
        patrolL:rx-40, patrolR:rx+40,
        searchUntil:0, lookTimer:0,
        anim:{state:'idle',runner:null}
      });
    }
    if(Math.random()<.6){
      const dx=startX+80+Math.random()*(CHUNK-160), dy=60+Math.random()*80;
      drones.push({x:dx|0,y:dy|0,w:18,h:14,dir:Math.random()<.5?-1:1,speed:.8,phase:Math.random()*6,active:false,anim:{state:'move',runner:null}});
    }
  }

  generatedUntil=endX; worldMaxX=Math.max(worldMaxX,endX);
}

/* ================= PHYSICS ================= */
function rects(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
function collide(body){
  body.onGround=false;

  // vertical
  body.y+=body.vy;
  for(const p of platforms){
    if(rects(body,p)){
      if(body.vy>0){ body.y=p.y-body.h; body.vy=0; body.onGround=true; coyoteUntil=0; }
      else if(body.vy<0){ body.y=p.y+p.h; body.vy=0; }
    }
  }

  // horizontal + tiny step-up
  body.x+=body.vx;
  for(const p of platforms){
    if(rects(body,p)){
      if(body.vx>0){
        body.y-=2; if(!rects(body,p)){ body.onGround=false; break; } body.y+=2;
      }else if(body.vx<0){
        body.y-=2; if(!rects(body,p)){ body.onGround=false; break; } body.y+=2;
      }
      if(body.vx>0) body.x=p.x-body.w; else if(body.vx<0) body.x=p.x+p.w;
      body.vx=0;
    }
  }
}

/* ================= HACK / EMP ================= */
let hackUntil=0, hackCDUntil=0; 
const getHackDuration = () => player?.upgrades?.advancedHack ? 5000 : 3000;
function tryHack(){
  const now=performance.now(); if(now<hackCDUntil) return;
  const near=terminals.find(t=>Math.hypot((t.x+6)-(player.x+player.w/2),(t.y+8)-(player.y+player.h/2))<18 && t.cooldown<=0);
  if(near){ const d=getHackDuration(); hackUntil=now+d; hackCDUntil=now+5000; near.cooldown=5000; score+=20; }
}

/* ================= COINS: BASE MAGNET + PICKUP ================= */
function pickupCoins(){
  for (const c of coins){
    if (c.taken) continue;
    const px = player.x + player.w/2, py = player.y + player.h/2;
    const dx = c.x - px, dy = c.y - py;
    const dist2 = dx*dx + dy*dy;

    const hasUpgrade = !!(player.upgrades && player.upgrades.coinMagnet);
    const magnetR = hasUpgrade ? 56 : 24;
    if (dist2 <= magnetR*magnetR){
      const d = Math.sqrt(dist2) || 1;
      const pull = hasUpgrade ? 1.3 : 0.65;
      c.x -= (dx/d) * pull;
      c.y -= (dy/d) * pull;
    }
    const rr = (c.r || 10) + 8;
    if (dist2 <= rr*rr){
      c.taken = true;
      btc += 1; score += 5;
    }
  }
}

/* ================= UPDATE ================= */
let coinImg=null, doorImg=null, ledgeImg=null, platformImg=null, platformRailImg=null;
let terminalFrame1=null, terminalFrame2=null;

async function loadTiles(){
  console.log('Loading tiles...', {
    coin: SPRITE_DEF.coin, door: SPRITE_DEF.door, ledge: SPRITE_DEF.ledge,
    platform: SPRITE_DEF.platform
  });
  try {
    coinImg     = await IMG(SPRITE_DEF.coin);
    doorImg     = await IMG(SPRITE_DEF.door);
    ledgeImg    = await IMG(SPRITE_DEF.ledge);
    platformImg = await IMG(SPRITE_DEF.platform);
    platformRailImg = await IMG(`assets/platform_rail.png?${HYPER_RELOAD_TAG}`);

    // Terminal animated frames only (no base hacker_terminal.png)
    terminalFrame1 = await IMG(`assets/hacker_terminal_frame1.png?${HYPER_RELOAD_TAG}`);
    terminalFrame2 = await IMG(`assets/hacker_terminal_frame2.png?${HYPER_RELOAD_TAG}`);
    if(!(terminalFrame1 && terminalFrame2)) console.warn('Terminal frames missing — fallback rects will render');

    const ok = (im)=>im && im.complete && im.naturalWidth>0;
    console[ok(coinImg)?'log':'error'](ok(coinImg)?'✓ Coin image':'✗ Failed to load coin', ok(coinImg)?`${coinImg.width}x${coinImg.height}`:SPRITE_DEF.coin);
    console[ok(doorImg)?'log':'error'](ok(doorImg)?'✓ Door image':'✗ Failed to load door', ok(doorImg)?`${doorImg.width}x${doorImg.height}`:SPRITE_DEF.door);
    console[ok(ledgeImg)?'log':'error'](ok(ledgeImg)?'✓ Ledge image':'✗ Failed to load ledge', ok(ledgeImg)?`${ledgeImg.width}x${ledgeImg.height}`:SPRITE_DEF.ledge);
    console[ok(platformImg)?'log':'warn'](ok(platformImg)?'✓ Platform image':'⚠ No platform_industrial (using ledge)', ok(platformImg)?`${platformImg.width}x${platformImg.height}`:'');
    if(ok(platformRailImg)) console.log('✓ Platform rail overlay:', platformRailImg.width+'x'+platformRailImg.height);
  } catch (error) {
    console.error('Error loading tiles:', error);
  }
}

function cull(){ const cutoff=cameraX-300;
  for(let i=ads.length-1;i>=0;i--) if(ads[i].x+160<cutoff) ads.splice(i,1);
  for(let i=robots.length-1;i>=0;i--) if(robots[i].x+120<cutoff) robots.splice(i,1);
  for(let i=drones.length-1;i>=0;i--) if(drones[i].x+120<cutoff) drones.splice(i,1);
  for(let i=coins.length-1;i>=0;i--) if(coins[i].x+40<cutoff) coins.splice(i,1);
}
function activateEnemies(){
  const visRight = cameraX + VW + 64;
  for(const r of robots){ if(!r.active && r.x<visRight) r.active=true; }
  for(const d of drones){ if(!d.active && d.x<visRight) d.active=true; }
}

function update(dt,now){
  if(gameState!=='playing') return;

  // terminals cooldown tick
  for(const t of terminals){ if(t.cooldown>0) t.cooldown=Math.max(0,t.cooldown-dt); }

  const L=!!keys['ArrowLeft'], R=!!keys['ArrowRight'];
  const accel=player.onGround?player.aGround:player.aAir;
  const drag=player.onGround?player.dragG:player.dragA;
  if(L){ player.vx=Math.max(player.vx-accel,-player.speed); player.facing=-1; }
  if(R){ player.vx=Math.min(player.vx+accel, player.speed);  player.facing= 1; }
  if(!L && !R) player.vx*=drag;

  if(player.onGround) coyoteUntil=now+COYOTE;
  const wantsJump = now<=jumpBufferUntil;
  if(wantsJump && (player.onGround || now<=coyoteUntil)){ player.vy=-player.jump; player.onGround=false; jumpBufferUntil=0; coyoteUntil=0; }
  if(!jumpHeld && player.vy<-1.25) player.vy=-1.25;

  player.vy+=.18; if(player.vy>3.7) player.vy=3.7;

  collide(player);
  pickupCoins();

  if(player.hp<=0) setAnim(player,'player','dead',true);
  else if(now<player.hitUntil) setAnim(player,'player','hurt',true);
  else if(!player.onGround) setAnim(player,'player', player.vy<0?'jump':'fall');
  else { const s=Math.abs(player.vx); setAnim(player,'player', s>1.05?'run':(s>0.2?'walk':'idle')); }
  stepAnim(player,dt);

  const need=cameraX+VW+CHUNK*2; while(generatedUntil<need) genChunk(generatedUntil);

  activateEnemies();
  const hacked = now<hackUntil;

  for(const d of drones){
    if(!d.active) continue;
    if(!hacked){
      d.x+=d.dir*d.speed; d.phase+=.02; d.y+=Math.sin(d.phase)*.2;
      if((d.x%CHUNK)<8||(d.x%CHUNK)>CHUNK-8) d.dir*=-1;
    }
  }

  // ===== ROBOT AI =====
  for(const r of robots){
    if(!r.active) continue;

    const dx = player.x - r.x;
    const dy = player.y - r.y;
    const see = Math.abs(dx) < 92 && Math.abs(dy) < 56;

    const playerAbove = (player.y + player.h) < (r.y - 6);
    let hasFloorBetween = false;
    if(playerAbove){
      for(const p of platforms){
        const betweenY = (p.y >= player.y) && (p.y <= r.y);
        const overlapX = (r.x > p.x - 8) && (r.x < p.x + p.w + 8);
        if(betweenY && overlapX){ hasFloorBetween = true; break; }
      }
    }

    if(see && !(playerAbove && hasFloorBetween)){
      r.state = 'chase'; r.alert = true; r.dir = dx > 0 ? 1 : -1; r.x += r.dir * r.speed * 1.25;
    } else if(playerAbove){
      if(r.state !== 'search'){
        r.state='search'; r.alert=false; r.searchUntil=now+2500+Math.random()*2000;
        const offset = (dx > 0 ? -1 : 1) * (24 + Math.random()*28);
        const c = r.x + offset, span = 28 + Math.random()*18;
        r.patrolL=c - span; r.patrolR=c + span; r.dir = Math.random()<.5?-1:1; r.lookTimer = now + 600 + Math.random()*800;
      }
      if(now > r.lookTimer){ r.dir *= -1; r.lookTimer = now + 600 + Math.random()*900; }
      r.x += r.dir * r.speed * 0.9;
      if(r.x < r.patrolL){ r.x = r.patrolL; r.dir = 1; }
      if(r.x > r.patrolR){ r.x = r.patrolR; r.dir = -1; }
      if(now > r.searchUntil) r.state='patrol';
    } else {
      r.alert=false;
      if(r.state!=='patrol'){ r.state='patrol'; r.patrolL=r.x-40; r.patrolR=r.x+40; r.dir = Math.sign(dx)||1; }
      r.x += r.dir * r.speed;
      if(r.x < r.patrolL){ r.x = r.patrolL; r.dir = 1; }
      if(r.x > r.patrolR){ r.x = r.patrolR; r.dir = -1; }
    }

    setAnim(r,'robot', r.state==='chase' ? 'run' : 'walk'); stepAnim(r,dt);

    if(rects(player,r)){
      if(player.vy>0 && player.y+player.h<=r.y+6){ r.hp--; r.hitUntil=now+120; player.vy=-2.6; score+=12; }
      else{
        player.vx+=(player.x<r.x)?-0.8:0.8;
        const damage = player.upgrades?.armor ? 5 : 7;
        player.hp-=damage; player.hitUntil=now+150;
        if(player.hp<=0){ gameState='gameOver'; resetBtn.style.display='block'; }
      }
    }
  }
  for(let i=robots.length-1;i>=0;i--) if(robots[i].hp<=0) robots.splice(i,1);

  if(exitDoor && rects(player, exitDoor)){
    gameState='levelComplete';
    setTimeout(()=>{ 
      const shopUrl = `${SHOP_URL}?btc=${btc}&score=${score}&level=${level}`;
      window.location.href = shopUrl;
    }, 300);
  }

  updateCamera(); cull();
  player.dist=Math.max(player.dist,player.x);
  const nl=(player.dist/LEVEL_LEN|0)+1; if(nl>level){ level=nl; justLeveled=1200; }
}

/* ================= DRAW ================= */
function drawTiles(){
  const ok = (im)=>im && im.complete && im.naturalWidth>0;
  const img = ok(ledgeImg) ? ledgeImg : (ok(platformImg) ? platformImg : null);

  const RAIL_FRAC   = 0.55;
  const DST_BASE_H  = 20;

  for (const p of platforms){
    const sx = p.x - cameraX; if (sx + p.w < 0 || sx > VW) continue;

    if (!ok(img)){
      ctx.fillStyle = '#1a2332'; ctx.fillRect(sx|0, p.y|0, p.w, TILE);
      ctx.fillStyle = '#6fc2ff'; ctx.fillRect(sx|0, p.y|0, p.w, 2);
      ctx.fillStyle = '#4a5568'; ctx.fillRect(sx|0, (p.y+TILE-2)|0, p.w, 2);
      continue;
    }

    const iw = img.naturalWidth, ih = img.naturalHeight;
    const srcBaseY = Math.floor(ih * RAIL_FRAC);
    const srcBaseH = ih - srcBaseY;
    const srcX = 1, srcW = Math.max(1, iw - 2);
    const dy = (p.y - (DST_BASE_H - TILE)) | 0;
    ctx.drawImage(img, srcX, srcBaseY, srcW, srcBaseH, sx|0, dy, p.w, DST_BASE_H);
  }
}

function drawRailsOnTop(){
  const ok = (im)=>im && im.complete && im.naturalWidth>0;
  const img = ok(ledgeImg) ? ledgeImg : null;
  if (!img) return;

  const RAIL_FRAC   = 0.55;
  const DST_BASE_H  = 20;

  const iw = img.naturalWidth, ih = img.naturalHeight;
  const railSrcH = Math.floor(ih * RAIL_FRAC);
  const baseSrcH = ih - railSrcH;
  const scale    = DST_BASE_H / baseSrcH;
  const railDstH = Math.max(10, Math.round(railSrcH * scale));
  const srcX = 1, srcW = Math.max(1, iw - 2);

  for (const p of platforms){
    if (p.y >= VH - TILE) continue;
    const sx = p.x - cameraX; if (sx + p.w < 0 || sx > VW) continue;
    const y  = (p.y - railDstH) | 0;
    ctx.drawImage(img, srcX, 0, srcW, railSrcH, sx|0, y, p.w, railDstH);
  }
}

function drawTerminals(){
  for(const t of terminals){ 
    const x=(t.x-cameraX)|0; if(x+t.w<0||x>VW) continue;

    const hasAnimFrames = terminalFrame1 && terminalFrame1.complete && terminalFrame2 && terminalFrame2.complete;
    let currentTerminalImg = null;
    if(hasAnimFrames) {
      const animSpeed = 300;
      const frameIndex = Math.floor(performance.now() / animSpeed) % 2;
      currentTerminalImg = frameIndex === 0 ? terminalFrame1 : terminalFrame2;
    }

    if(currentTerminalImg && currentTerminalImg.complete && currentTerminalImg.naturalWidth){
      ctx.save();
      if(t.cooldown <= 0) { ctx.shadowColor = '#00ff9d'; ctx.shadowBlur = 4; }
      else { ctx.shadowColor = '#ff4444'; ctx.shadowBlur = 2; }
      ctx.drawImage(currentTerminalImg, x-2, t.y-4, t.w+4, t.h+4);
      ctx.restore();
      if(t.cooldown > 0) {
        ctx.fillStyle = 'rgba(255, 68, 68, 0.8)';
        ctx.fillRect(x, t.y-2, Math.max(1, (t.w * (t.cooldown / 5000))), 2);
      }
    }else{
      ctx.fillStyle = t.cooldown > 0 ? '#6b4d9b' : '#9b6bff'; 
      ctx.fillRect(x,t.y,t.w,t.h);
      ctx.fillStyle = t.cooldown > 0 ? '#ccc' : '#fff'; 
      ctx.fillRect(x+2,t.y+3,t.w-4,3);
      ctx.fillStyle = '#00ff9d'; ctx.font = '6px monospace'; ctx.fillText('HACK', x+1, t.y+t.h-2);
    }
  }
}

function drawCoins(now){
  for(const c of coins){
    if(c.taken) continue;
    const x=(c.x-cameraX)|0, y=c.y|0; if(x<-16||x>VW+16) continue;
    if(coinImg && coinImg.complete && coinImg.naturalWidth){
      const coinSize = 20;
      ctx.save(); ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 8;
      ctx.drawImage(coinImg, x-coinSize/2, y-coinSize/2, coinSize, coinSize);
      ctx.restore();
    }else{
      ctx.fillStyle='#ffd95e'; ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='#ffaa00'; ctx.lineWidth=2; ctx.stroke();
      ctx.fillStyle='#000'; ctx.font='8px monospace'; ctx.textAlign='center'; ctx.fillText('₿', x, y+2);
      ctx.textAlign='left';
    }
  }
}

function drawEntities(now){
  for(const r of robots){
    const x=(r.x-cameraX)|0, y=r.y|0; if(x+48<0||x>VW) continue;
    drawAnim(r,'robot',x-14,y-24,(player.x<r.x), now<r.hitUntil?0.75:1);
  }
  for(const d of drones){
    const x=(d.x-cameraX)|0, y=d.y|0; if(x+32<0||x>VW) continue;
    if(!d.anim.runner) setAnim(d,'drone','move');
    stepAnim(d,16); drawAnim(d,'drone',x-7,y-9,false,1);
  }
  const px=(player.x-cameraX)|0, py=player.y|0;
  drawAnim(player,'player',px-15,py-20, player.facing===-1, performance.now()<player.hitUntil?0.8:1);
}

function drawExitDoor(){
  if(!exitDoor) return;
  const x=(exitDoor.x-cameraX)|0, y=exitDoor.y|0;
  if(x>VW||x+exitDoor.w<0) return;

  if(doorImg && doorImg.complete && doorImg.naturalWidth){
    ctx.save(); ctx.shadowColor = '#ff1493'; ctx.shadowBlur = 6;
    ctx.drawImage(doorImg, x, y, exitDoor.w, exitDoor.h);
    ctx.restore();
  }else{
    ctx.fillStyle='#2a3040'; ctx.fillRect(x,y,exitDoor.w,exitDoor.h); 
    ctx.fillStyle='#6fc2ff'; ctx.fillRect(x+exitDoor.w-6,y+exitDoor.h/2-3,4,6);
    ctx.fillStyle='#8fb3ff'; ctx.fillRect(x+2,y+4,exitDoor.w-4,3);
    ctx.fillStyle='#a0c4ff'; ctx.fillRect(x+2,y+8,exitDoor.w-4,2);
    ctx.fillStyle='#7dff9a'; ctx.fillText('SHOP',x+3,y+exitDoor.h-8); ctx.fillText('DOOR',x+3,y+exitDoor.h-2);
    ctx.strokeStyle='#6fc2ff'; ctx.lineWidth=1; ctx.strokeRect(x,y,exitDoor.w,exitDoor.h);
  }
}

/* ---------- FIT-TO-WIDTH CONTROLS HINT (no clip ever) ---------- */
function drawControlsHint() {
  const title = 'Blackout Protocol';
  ctx.font='9px monospace'; ctx.textAlign='left';
  const titleW = ctx.measureText(title).width;
  ctx.fillStyle='#cfd6df'; ctx.fillText(title,6,4);

  const pad = 6;
  const avail = VW - (titleW + pad*2 + 2);

  const candidates = [
    {text:'← → Move | Space | Enter | ESC', size:8},
    {text:'← → Move | Space | Enter',      size:8},
    {text:'← → | Space | Enter | ESC',     size:8},
    {text:'←→|Space|Enter|ESC',            size:7},
    {text:'←→|␣|⏎|ESC',                   size:7},
    {text:'←→ ␣ ⏎ ESC',                   size:6},
  ];

  let choice = candidates[0];
  for (const c of candidates){
    ctx.font = `${c.size}px monospace`;
    if (ctx.measureText(c.text).width <= avail){ choice=c; break; }
  }

  ctx.textAlign='right';
  ctx.fillStyle='#9aa3b2';
  ctx.font = `${choice.size}px monospace`;
  ctx.fillText(choice.text, VW-4, 4);

  // restore defaults
  ctx.textAlign='left';
  ctx.font='9px monospace';
}

function drawUI(now){
  // top bar
  ctx.fillStyle='rgba(0,0,0,.78)'; ctx.fillRect(0,0,VW,20);
  drawControlsHint();

  // stats line
  ctx.fillStyle='#fff'; ctx.fillText(`HP:${Math.max(0,player.hp)}  L:${level}  SC:${score}  BTC:${btc}`,6,24);
  ctx.fillStyle='#7dff9a'; ctx.fillText(`DIST:${player.dist|0}  DOOR@:${(LEVEL_LEN-40)|0}`, 6, 36);

  const left=Math.max(0,hackUntil-now)|0;
  if(left>0){ ctx.fillStyle='#7dff9a'; ctx.fillText(`EMP ${Math.ceil(left/1000)}s`,6,48); }
  else if(now<hackCDUntil){ ctx.fillStyle='#7f8a99'; ctx.fillText(`Hack CD ${((hackCDUntil-now)/1000|0)}s`,6,48); }
  else { ctx.fillStyle='#7dff9a'; ctx.fillText('Enter: Hack',6,48); }

  if(gameState==='paused'){ ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,VW,VH); ctx.fillStyle='#fff'; ctx.fillText('PAUSED (ESC)',VW/2-30,VH/2); }
  if(gameState==='gameOver'){ ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(0,0,VW,VH); ctx.fillStyle='#fff'; ctx.fillText('GAME OVER',VW/2-34,VH/2-8); ctx.fillText(`Score ${score}  BTC ${btc}`,VW/2-40,VH/2+4); ctx.fillText('Press R or click Reset',VW/2-54,VH/2+16); }
  if(gameState==='levelComplete'){ ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(0,0,VW,VH); ctx.fillStyle='#7dff9a'; ctx.fillText('LEVEL COMPLETE → SHOP',VW/2-60,VH/2-8); }
}

/* ======== HOLOGRAM AD OVERLAY ======== */
function drawOverlay(now){
  octx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  const vis=[];
  for(const a of ads){
    const sx=Math.round(RENDER.ox+(a.x-cameraX)*RENDER.scale);
    const sy=Math.round(RENDER.oy+a.y*RENDER.scale);
    if(sx>-200 && sx<overlayCanvas.width+200 && sy<overlayCanvas.height*0.85) vis.push({a,sx,sy});
  }
  octx.save();
  for(const {a,sx,sy} of vis){
    a.phase = (a.phase||0) + 0.03;
    const flick = 0.65 + 0.35*Math.sin(a.phase*3);
    const bob   = Math.sin(a.phase)*2*RENDER.scale;
    const tilt  = (Math.sin(a.phase*0.6))*0.03;

    let img=null;
    if(a.kind==='fourk') img = AdImages.fourk;
    else if(a.kind==='meat') img = AdImages.meat;
    else if(a.kind==='holo') img = AdImages.holo;
    else if(a.kind==='rent') img = AdImages.rent;
    else if(a.kind==='drink') img = (Math.floor((performance.now()/350))%2===0 ? AdImages.drink[0] : AdImages.drink[1]);
    if(!img) continue;

    const targetW = Math.round(56*RENDER.scale);
    const ratio = img.height ? (img.width/img.height) : 1;
    const w = targetW, h = Math.max(11, Math.round((targetW/ratio)));
    const x = sx - Math.round(w/2), y = sy - Math.round(h/2) + bob;

    octx.globalAlpha = 0.85;
    octx.fillStyle = 'rgba(10,14,20,0.5)';
    octx.fillRect(x-8,y-8,w+16,h+16);
    octx.globalAlpha = 1;
    octx.strokeStyle = `rgba(111,194,255,0.5)`;
    octx.lineWidth = 2;
    octx.strokeRect(x-8,y-8,w+16,h+16);

    octx.save();
    octx.translate(x+w/2, y+h/2);
    octx.rotate(tilt);
    octx.globalAlpha = 0.72 + 0.12*Math.sin(a.phase*2);
    octx.drawImage(img, -w/2, -h/2, w, h);
    octx.globalAlpha = 0.18 * flick;
    octx.shadowColor = '#6fc2ff';
    octx.shadowBlur  = 22;
    octx.drawImage(img, -w/2, -h/2, w, h);
    octx.restore();

    octx.globalAlpha = 0.12*flick;
    octx.fillStyle = '#6fc2ff';
    octx.fillRect(x-8, y + (h*0.2|0), w+16, 1);
    octx.globalAlpha = 1;
  }
  octx.restore();
}

/* ================= BLIT ================= */
function blit(){
  gctx.clearRect(0,0,gameCanvas.width,gameCanvas.height);
  const s=Math.min(gameCanvas.width/VW, gameCanvas.height/VH);
  const sw=(VW*s)|0, sh=(VH*s)|0, ox=((gameCanvas.width-sw)/2)|0, oy=((gameCanvas.height-sh)/2)|0;
  gctx.drawImage(nes,0,0,VW,VH,ox,oy,sw,sh); RENDER={scale:s,ox,oy};
}

/* ================= RESET / BOOT / LOOP ================= */
function placeExitDoor(){
  const x=LEVEL_LEN-40, y=groundY()-DOOR_H;
  exitDoor={x, y, w:DOOR_W, h:DOOR_H};
}

function reset(){
  const savedBTC   = parseInt(localStorage.getItem('playerBTC'))   || 0;
  const savedScore = parseInt(localStorage.getItem('playerScore')) || 0;
  const savedLevel = parseInt(localStorage.getItem('gameLevel'))   || 1;

  gameState='playing'; cameraX=0; worldMaxX=0; 
  score=savedScore; btc=savedBTC; level=savedLevel; justLeveled=0;
  platforms=[]; robots=[]; drones=[]; terminals=[]; ads=[]; coins=[]; generatedUntil=0; exitDoor=null;
  player=makePlayer(); setAnim(player,'player','idle');
  for(let x=0;x<CHUNK*4;x+=CHUNK) genChunk(x);
  placeExitDoor();
  resetBtn.style.display='none';

  if(savedLevel > 1) {
    localStorage.removeItem('playerBTC');
    localStorage.removeItem('playerScore'); 
    localStorage.removeItem('playerHealth');
    localStorage.removeItem('gameLevel');
  }
}

async function assetSelfTest(){
  try{
    const urls=[];
    const push=(u)=>u&&urls.push(u);
    ['player','robot','drone'].forEach(k=>{
      const o=SPRITE_DEF[k]; if(o&&o.states) Object.values(o.states).forEach(push);
    });
    ['bg_far','bg_near','coin','door','ledge','platform'].forEach(k=>push(SPRITE_DEF[k]));
    // terminal base intentionally omitted
    ['fourk','meat','holo','rent','drinkA','drinkB',
     `assets/hacker_terminal_frame1.png?${HYPER_RELOAD_TAG}`,
     `assets/hacker_terminal_frame2.png?${HYPER_RELOAD_TAG}`
    ].forEach(push);
    const head=async u=>{ try{ const r=await fetch(u,{method:'HEAD',cache:'no-store'}); return {u,ok:r.ok,st:r.status}; }catch{ return {u,ok:false,st:'net'}; } };
    const results=await Promise.all(urls.filter(Boolean).map(head));
    const bad=results.filter(r=>!r.ok);
    if(bad.length){
      console.group('%cMissing/blocked assets','color:#ffb36a');
      bad.forEach(b=>console.warn(b.st,b.u));
      console.groupEnd();
      window.__ASSET_ERRORS__=bad.map(b=>b.u);
    }else{
      console.info('All assets resolved (HEAD ok).');
      window.__ASSET_ERRORS__=[];
    }
  }catch(e){ console.warn('Asset self-test failed',e); }
}

async function boot(){
  try{
    SPR = await loadSprites(SPRITE_DEF);
    await Promise.all([loadBackgrounds(), loadTiles(), loadAdImages()]);
    await assetSelfTest();
    player = makePlayer(); setAnim(player,'player','idle');
    for(let x=0;x<CHUNK*4;x+=CHUNK) genChunk(x);
    placeExitDoor();
    gameState='playing'; READY=true;
  }catch(err){ console.error(err); LOAD_MSG='Load failed (check console)'; }
}
boot();

function loop(now){
  const dt = loop.t ? now - loop.t : 16; loop.t = now;
  if (!READY){
    ctx.fillStyle='#000'; ctx.fillRect(0,0,VW,VH);
    drawSky(); ctx.fillStyle='#cfd6df'; ctx.fillText(LOAD_MSG, VW/2 - 20, VH/2);
    blit(); requestAnimationFrame(loop); return;
  }
  if (gameState==='playing') update(dt, now);
  ctx.fillStyle='#000'; ctx.fillRect(0,0,VW,VH);
  drawBackgrounds();
  drawTiles(); drawTerminals(); drawCoins(now); drawExitDoor(); drawEntities(now); drawRailsOnTop(); drawUI(now);
  blit(); drawOverlay(now);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>

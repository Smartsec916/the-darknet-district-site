<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blackout Protocol — Sprite PNGs</title>
<style>
  :root { --frame-w: 960px; }
  html,body{margin:0;background:#000;color:#cfd6df;font-family:monospace;overflow:hidden;}
  #gameContainer{position:relative;width:100%;max-width:var(--frame-w);margin:0 auto;aspect-ratio:4/3;background:#000;border:2px solid #5c5c5c;}
  canvas{position:absolute;inset:0;display:block;image-rendering:pixelated;image-rendering:crisp-edges;}
  #overlayCanvas{pointer-events:none;}
  #resetBtn{position:absolute;left:50%;top:50%;transform:translate(-50%,-8px);padding:10px 16px;background:#0f1016;border:2px solid #626a78;border-radius:6px;color:#cfd6df;letter-spacing:.6px;display:none;cursor:pointer;z-index:5}
  #resetBtn:hover{filter:brightness(1.15)}
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <canvas id="overlayCanvas"></canvas>
  <button id="resetBtn" type="button">Reset (R)</button>
</div>

<script>
/* =========================================================
   DISPLAY SURFACE (NES-like internal buffer -> scaled canvas)
========================================================= */
const VW=256, VH=240, TILE=16;
const gameCanvas=document.getElementById('gameCanvas');
const overlayCanvas=document.getElementById('overlayCanvas');
const gctx=gameCanvas.getContext('2d'); gctx.imageSmoothingEnabled=false;
const octx=overlayCanvas.getContext('2d');
const nes=document.createElement('canvas'); nes.width=VW; nes.height=VH;
const ctx=nes.getContext('2d',{alpha:false}); ctx.imageSmoothingEnabled=false; ctx.font='8px monospace';
let RENDER={scale:1,ox:0,oy:0};
function fit(){ const r=document.getElementById('gameContainer').getBoundingClientRect();
  gameCanvas.width=r.width; gameCanvas.height=r.height; overlayCanvas.width=r.width; overlayCanvas.height=r.height; }
addEventListener('resize',fit); fit();

/* Kill page scroll on game keys (Space/Arrows) */
addEventListener('keydown',e=>{
  if(['Space','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.code)) e.preventDefault();
},{passive:false});

/* =========================================================
   ASSETS — per-state PNGs
   We auto-detect frame count by width / frameWidth
========================================================= */
const IMG=path=>new Promise(res=>{const i=new Image(); i.onload=()=>res(i); i.onerror=()=>res(null); i.src=path;});
const SPRITE_DEF={
  player:{fw:48,fh:48, states:{
    idle:'assets/player_idle_48.png',
    walk:'assets/player_walk_48.png',
    run:'assets/player_run_48.png',
    jump:'assets/player_jump_48.png',
    fall:'assets/player_fall_48.png',
    hurt:'assets/player_hurt_48.png',
    dead:'assets/player_dead_48.png'
  }, fps:{idle:6, walk:10, run:12, jump:10, fall:10, hurt:6, dead:8}},
  robot:{fw:48,fh:48, states:{
    idle:'assets/robot_idle_48.png',
    walk:'assets/robot_walk_48.png',
    run:'assets/robot_run_48.png',
    attack:'assets/robot_attack_48.png',
    hurt:'assets/robot_hurt_48.png',
    dead:'assets/robot_dead_48.png'
  }, fps:{idle:6, walk:9, run:10, attack:12, hurt:6, dead:8}},
  drone:{fw:32,fh:32, states:{
    idle:'assets/drone_idle_32.png',
    hover:'assets/drone_hover_32.png',
    move:'assets/drone_move_32.png',
    attack:'assets/drone_attack_32.png',
    hurt:'assets/drone_hurt_32.png',
    dead:'assets/drone_dead_32.png'
  }, fps:{idle:3, hover:10, move:10, attack:12, hurt:6, dead:8}},
  bg_far:'assets/01_bg_far.png',
  bg_mid:'assets/02_bg_mid.png',
  bg_near:'assets/03_bg_near.png',
  fg_rail:'assets/04_fg_rail.png'
};

function makeAnimator(sheet, fw, fh, fps){
  // sheet: image containing N frames horizontally; auto-detect N.
  const frames = sheet ? Math.max(1, Math.floor(sheet.width / fw)) : 1;
  let frame=0, time=0, spf=1000/(fps||8);
  return {
    reset(){ frame=0; time=0; },
    step(dt, clamp=false){ time+=dt; while(time>spf){ time-=spf; frame = clamp ? Math.min(frame+1, frames-1) : (frame+1)%frames; } },
    draw(x,y,flip=false,alpha=1){
      if(!sheet) return;
      const sx=frame*fw, sy=0;
      ctx.save(); ctx.globalAlpha=alpha;
      if(flip){ ctx.translate(x+fw,y); ctx.scale(-1,1); ctx.drawImage(sheet,sx,sy,fw,fh,0,0,fw,fh); }
      else    { ctx.drawImage(sheet,sx,sy,fw,fh,x,y,fw,fh); }
      ctx.restore();
    },
    frames
  };
}

async function loadSprites(def){
  const out={};
  for(const who of ['player','robot','drone']){
    const fw=def[who].fw, fh=def[who].fh;
    const pack={fw,fh, anim:{}};
    for(const [state,src] of Object.entries(def[who].states)){
      const img=await IMG(src);
      pack.anim[state]={
        img,
        make:()=>makeAnimator(img,fw,fh, def[who].fps[state]||8)
      };
    }
    out[who]=pack;
  }
  const bg={};
  bg.far = await IMG(def.bg_far);
  bg.mid = await IMG(def.bg_mid);
  bg.near= await IMG(def.bg_near);
  bg.rail= await IMG(def.fg_rail);
  out.bg=bg;
  return out;
}

/* =========================================================
   GAMESTATE, INPUT, CAMERA
========================================================= */
let gameState='loading', score=0, level=1, justLeveled=0;
let cameraX=0, worldMaxX=0;
const CHUNK=320, LEVEL_LEN=1600;

const DEAD_ZONE=2; // ← tighter center. Increase to widen.
function updateCamera(){
  const center=VW*.5, L=center-DEAD_ZONE, R=center+DEAD_ZONE;
  let target=cameraX;
  if(player.x-cameraX<L) target=player.x-L;
  else if(player.x-cameraX>R) target=player.x-R;
  cameraX += (target-cameraX)*.25;
  cameraX=Math.max(0,Math.min(cameraX, worldMaxX-VW));
}

const keys={}, JUMP_BUFFER=120, COYOTE=120;
let jumpBufferUntil=0, coyoteUntil=0, jumpHeld=false;
addEventListener('keydown',e=>{
  keys[e.code]=true;
  if(e.code==='Escape') gameState=(gameState==='playing')?'paused':'playing';
  if(e.code==='Space'){ jumpBufferUntil=performance.now()+JUMP_BUFFER; jumpHeld=true; }
  if(e.code==='KeyR' && gameState==='gameOver') reset();
  if(e.code==='Enter' && gameState==='playing') tryHack();
});
addEventListener('keyup',e=>{ keys[e.code]=false; if(e.code==='Space') jumpHeld=false; });

/* =========================================================
   ENTITIES
========================================================= */
let SPR=null;
let bgFar=null,bgMid=null,bgNear=null,fgRail=null;

let player, robots=[], drones=[], platforms=[], terminals=[], ads=[];
const resetBtn=document.getElementById('resetBtn'); resetBtn.onclick=()=>reset();

function makePlayer(){
  // Player collision box is slightly smaller than 48x48 visuals for feel
  return { x:32, y:VH-80, w:18, h:28, vx:0, vy:0, onGround:false, facing:1,
           speed:1.48, aGround:.18, aAir:.11, dragG:.82, dragA:.985, jump:3.65,
           hp:100, dist:0, hitUntil:0, anim: { state:'idle', runner:null } };
}

function setAnim(actor, who, state, clamp=false){
  if(actor.anim.state===state) return;
  actor.anim.state=state;
  const spec=SPR[who].anim[state];
  actor.anim.runner = spec ? spec.make() : null;
  if(actor.anim.runner) actor.anim.runner.reset();
  actor.anim.clamp = clamp;
}

function stepAnim(actor, dt){ if(actor.anim.runner) actor.anim.runner.step(dt, actor.anim.clamp); }
function drawAnim(actor, who, x, y, flip=false, alpha=1){
  const run=actor.anim.runner;
  if(run) run.draw(x,y,flip,alpha);
}

/* =========================================================
   WORLD GEN
========================================================= */
const ADS_TXT=[
  "Neon Nights — Discretion Included","HoloCompanion™ — Terms Apply",
  "Love.exe — Try a Free Emote","Rent-A-Hacker — We Never Met You",
  "Sleep Faster™ — Productivity Pills","Oxygen+ — Premium Breaths"
];
const choice = a => a[(Math.random()*a.length)|0];
let generatedUntil=0, worldMax=0;

function genChunk(startX){
  const endX=startX+CHUNK;

  // Ground tiles
  for(let x=startX;x<endX;x+=TILE) platforms.push({x,y:VH-TILE,w:TILE,h:TILE});

  // Floating platforms
  const pc=2+((Math.random()*3)|0);
  for(let i=0;i<pc;i++){
    const px=startX+40+Math.random()*(CHUNK-80);
    const py=VH-(64+((Math.random()*96)|0));
    const pw=TILE*(2+((Math.random()*3)|0));
    platforms.push({x:(px/TILE|0)*TILE,y:(py/TILE|0)*TILE,w:pw,h:TILE});
  }

  // Robots
  const rc=1+((Math.random()*2)|0);
  for(let i=0;i<rc;i++){
    const rx=startX+64+Math.random()*(CHUNK-128);
    robots.push({x:rx|0,y:VH-TILE*2,w:18,h:24,dir:Math.random()<.5?-1:1,speed:.66,hp:3,alert:false,hitUntil:0,anim:{state:'idle',runner:null}});
  }

  // Drones
  if(Math.random()<.6){
    const dx=startX+80+Math.random()*(CHUNK-160), dy=60+Math.random()*80;
    drones.push({x:dx|0,y:dy|0,w:18,h:14,dir:Math.random()<.5?-1:1,speed:.8,phase:Math.random()*6,anim:{state:'move',runner:null}});
  }

  // Hack terminals
  if(Math.random()<.5){
    const tx=startX+40+Math.random()*(CHUNK-80); let ty=VH-TILE*2;
    for(const p of platforms){ if(tx>=p.x-4 && tx<=p.x+p.w+4) ty=Math.min(ty,p.y-TILE); }
    terminals.push({x:tx|0,y:ty|0,w:12,h:16,cooldown:0});
  }

  // Hologram ad anchors (1–2)
  const ac=1+((Math.random()*2)|0);
  for(let i=0;i<ac;i++){
    const ax=startX+40+Math.random()*(CHUNK-80), ay=VH-(120+((Math.random()*60)|0));
    ads.push({x:ax|0,y:ay|0,text:choice(ADS_TXT),phase:Math.random()*6});
  }

  generatedUntil=endX; worldMaxX=Math.max(worldMaxX,endX);
}

/* =========================================================
   PHYSICS / COLLISIONS
========================================================= */
function rects(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
function collide(body){
  body.onGround=false;
  body.y+=body.vy;
  for(const p of platforms){
    if(rects(body,p)){
      if(body.vy>0){ body.y=p.y-body.h; body.vy=0; body.onGround=true; coyoteUntil=0; }
      else if(body.vy<0){ body.y=p.y+p.h; body.vy=0; }
    }
  }
  body.x+=body.vx;
  for(const p of platforms){
    if(rects(body,p)){
      if(body.vx>0) body.x=p.x-body.w; else if(body.vx<0) body.x=p.x+p.w;
      body.vx=0;
    }
  }
}

/* =========================================================
   HACK / EMP
========================================================= */
let hackUntil=0, hackCDUntil=0; const HACK_MS=3000, CD_MS=5000;
function tryHack(){
  const now=performance.now(); if(now<hackCDUntil) return;
  const near=terminals.find(t=>Math.hypot((t.x+6)-(player.x+player.w/2),(t.y+8)-(player.y+player.h/2))<18 && t.cooldown<=0);
  if(near){ hackUntil=now+HACK_MS; hackCDUntil=now+CD_MS; near.cooldown=CD_MS; score+=20; }
}

/* =========================================================
   UPDATE LOOP
========================================================= */
function cull(){ const cutoff=cameraX-300;
  for(let i=ads.length-1;i>=0;i--) if(ads[i].x+120<cutoff) ads.splice(i,1);
  for(let i=robots.length-1;i>=0;i--) if(robots[i].x+120<cutoff) robots.splice(i,1);
  for(let i=drones.length-1;i>=0;i--) if(drones[i].x+120<cutoff) drones.splice(i,1);
}

function update(dt,now){
  if(gameState!=='playing') return;

  // Movement
  const L=!!keys['ArrowLeft'], R=!!keys['ArrowRight'];
  const accel=player.onGround?player.aGround:player.aAir;
  const drag=player.onGround?player.dragG:player.dragA;
  if(L){ player.vx=Math.max(player.vx-accel,-player.speed); player.facing=-1; }
  if(R){ player.vx=Math.min(player.vx+accel, player.speed);  player.facing= 1; }
  if(!L && !R) player.vx*=drag;

  if(player.onGround) coyoteUntil=now+COYOTE;
  const wantsJump = now<=jumpBufferUntil;
  if(wantsJump && (player.onGround || now<=coyoteUntil)){ player.vy=-player.jump; player.onGround=false; jumpBufferUntil=0; coyoteUntil=0; }
  if(!jumpHeld && player.vy<-1.2) player.vy=-1.2;

  player.vy+=.18; if(player.vy>3.6) player.vy=3.6;
  collide(player);

  // Player anim
  if(player.hp<=0) setAnim(player,'player','dead',true);
  else if(now<player.hitUntil) setAnim(player,'player','hurt',true);
  else if(!player.onGround) setAnim(player,'player', player.vy<0?'jump':'fall');
  else {
    const s=Math.abs(player.vx);
    setAnim(player,'player', s>1.05?'run':(s>0.2?'walk':'idle'));
  }
  stepAnim(player,dt);

  // Generate ahead
  const need=cameraX+VW+CHUNK*2; while(generatedUntil<need) genChunk(generatedUntil);

  // Drones AI
  const hacked = now<hackUntil;
  for(const d of drones){
    if(!hacked){
      d.x+=d.dir*d.speed; d.phase+=.02; d.y+=Math.sin(d.phase)*.2;
      if((d.x%CHUNK)<8||(d.x%CHUNK)>CHUNK-8) d.dir*=-1;
      // vertical scan (alert robots)
      if(player.x+player.w>d.x-6 && player.x<d.x+d.w+6 && player.y>d.y){
        let blocked=false; const scan={x:d.x,y:d.y,w:d.w,h:(player.y-d.y)};
        for(const p of platforms){ if(rects(scan,p)){ blocked=true; break; } }
        if(!blocked){ for(const r of robots){ if(Math.abs(r.x+d.x)<9999){} } // noop; just flavor
          for(const r of robots){ if(Math.abs(r.x-d.x)<140) r.alert=true; } }
      }
    }
  }

  // Robot AI + combat
  for(const r of robots){
    if(!hacked){
      const see=Math.abs(r.x-player.x)<92 && Math.abs(r.y-player.y)<56;
      if(see) r.alert=true;
      if(r.alert) r.x+=(player.x>r.x?1:-1)*r.speed*1.25;
      else { r.x+=r.dir*r.speed; if((r.x%110)<1) r.dir*=-1; }
    }
    // Anim
    setAnim(r,'robot', r.alert?'run':'walk'); stepAnim(r,dt);
    // Collide with player
    if(rects(player,r)){
      if(player.vy>0 && player.y+player.h<=r.y+6){ r.hp--; r.hitUntil=now+120; player.vy=-2.6; score+=12; }
      else{ player.vx+=(player.x<r.x)?-0.8:0.8; player.hp-=7; player.hitUntil=now+150; if(player.hp<=0){ gameState='gameOver'; resetBtn.style.display='block'; } }
    }
  }
  for(let i=robots.length-1;i>=0;i--) if(robots[i].hp<=0) robots.splice(i,1);

  updateCamera(); cull();
  player.dist=Math.max(player.dist,player.x);
  const nl=(player.dist/LEVEL_LEN|0)+1; if(nl>level){ level=nl; justLeveled=1200; }
}

/* =========================================================
   DRAW — sky/parallax/world/sprites/ads/UI
========================================================= */
function drawSky(){
  for(let y=0;y<VH;y++){ const t=y/VH; ctx.fillStyle=`rgb(${12+18*t|0},${16+30*t|0},${30+58*t|0})`; ctx.fillRect(0,y,VW,1); }
}

function tileLayer(img,y,speed,alpha=1){
  if(!img) return;
  const cx=cameraX|0, w=img.width; if(!w) return;
  const off=-(cx*speed|0)%w;
  ctx.save(); ctx.globalAlpha=alpha;
  for(let x=off-w;x<VW;x+=w) ctx.drawImage(img,x,y);
  ctx.restore();
}
function drawParallax(){
  tileLayer(bgFar||bgMid||bgNear, VH-170, 0.25, 1.0);
  tileLayer(bgMid||bgFar,          VH-160, 0.50, 0.90);
  tileLayer(bgNear||bgFar,         VH-150, 0.90, 0.90);
  if(fgRail) tileLayer(fgRail,     VH-44 , 1.00, 1.0);
}

function drawTiles(){
  for(const p of platforms){
    const sx=p.x-cameraX; if(sx+p.w<0||sx>VW) continue;
    for(let x=0;x<p.w;x+=TILE) for(let y=0;y<p.h;y+=TILE){
      const xx=sx+x, yy=p.y+y, even=((((xx|0)>>4)+(((yy|0)>>4)))%2)===0;
      ctx.fillStyle=even?'#3a3f47':'#2c3038'; ctx.fillRect(xx|0,yy|0,TILE,TILE);
      if(y===0){ ctx.fillStyle='#98a0b0'; ctx.fillRect(xx|0,yy|0,TILE,1); }
    }
  }
}
function drawTerminals(){
  for(const t of terminals){ const x=(t.x-cameraX)|0; if(x+t.w<0||x>VW) continue;
    ctx.fillStyle='#9b6bff'; ctx.fillRect(x,t.y,t.w,t.h);
    ctx.fillStyle='#fff'; ctx.fillRect(x+2,t.y+3,t.w-4,3);
  }
}

function drawEntities(now){
  // Robots
  for(const r of robots){
    const x=(r.x-cameraX)|0, y=r.y|0; if(x+48<0||x>VW) continue;
    drawAnim(r,'robot',x-14,y-24,(player.x<r.x), now<r.hitUntil?0.75:1);
  }
  // Drones
  for(const d of drones){
    const x=(d.x-cameraX)|0, y=d.y|0; if(x+32<0||x>VW) continue;
    if(!d.anim.runner) setAnim(d,'drone','move');
    stepAnim(d,16); drawAnim(d,'drone',x-7,y-9,false,1);
  }
  // Player
  const px=(player.x-cameraX)|0, py=player.y|0;
  drawAnim(player,'player',px-15,py-20, player.facing===-1, performance.now()<player.hitUntil?0.8:1);
}

function drawUI(now){
  // HUD inside the game area
  ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,VW,18);
  ctx.fillStyle='#cfd6df'; ctx.fillText('Blackout Protocol',6,6);
  ctx.fillStyle='#9aa3b2'; ctx.fillText('← → Move | Space Jump | Enter Hack | ESC Pause',120,6);
  ctx.fillStyle='#fff'; ctx.fillText(`HP:${Math.max(0,player.hp)}  L:${level}  SC:${score}`,6,28);

  const left=Math.max(0,hackUntil-now)|0;
  if(left>0){ ctx.fillStyle='#7dff9a'; ctx.fillText(`EMP ${Math.ceil(left/1000)}s`,6,40); }
  else if(now<hackCDUntil){ ctx.fillStyle='#7f8a99'; ctx.fillText(`Hack CD ${((hackCDUntil-now)/1000|0)}s`,6,40); }
  else { ctx.fillStyle='#7dff9a'; ctx.fillText('Enter: Hack',6,40); }

  if(gameState==='paused'){ ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,VW,VH); ctx.fillStyle='#fff'; ctx.fillText('PAUSED (ESC)',VW/2-30,VH/2); }
  if(gameState==='gameOver'){ ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(0,0,VW,VH);
    ctx.fillStyle='#fff'; ctx.fillText('GAME OVER',VW/2-34,VH/2-8); ctx.fillText(`Score ${score}`,VW/2-26,VH/2+4);
    ctx.fillText('Press R or click Reset',VW/2-54,VH/2+16); }

  if(justLeveled>0){ ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(0,56,VW,18); ctx.fillStyle='#ffd95e'; ctx.fillText(`LEVEL UP → ${level}`,VW/2-36,68); justLeveled-=16; }

  // Warnings if assets missing
  let y=VH-10; const warn=msg=>{ ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(2,y-7,VW-4,9); ctx.fillStyle='#ffb36a'; ctx.fillText(msg,6,y-6); y-=10; };
  if(!SPR.player.anim.idle.img) warn('Missing player_* PNGs');
  if(!SPR.robot.anim.idle.img)  warn('Missing robot_* PNGs');
  if(!SPR.drone.anim.idle.img)  warn('Missing drone_* PNGs');
  if(!bgFar) warn('Missing: assets/01_bg_far.png (using gradient sky)');
}

function drawOverlay(now){
  octx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  // At most 2 hologram ads, semi-transparent, with glow; they move with world
  const vis=[];
  for(const a of ads){
    const sx=Math.round(RENDER.ox+(a.x-cameraX)*RENDER.scale);
    const sy=Math.round(RENDER.oy+a.y*RENDER.scale);
    if(sx>-140 && sx<overlayCanvas.width+140 && sy<overlayCanvas.height*0.78) vis.push({a,sx,sy});
  }
  vis.sort((p,q)=>p.sx-q.sx);
  const two=vis.slice(0,2);
  octx.save(); octx.textBaseline='top';
  for(const {a,sx,sy} of two){
    const color=/Nights|Love|Companion/i.test(a.text)?'#ffd95e':'#6fc2ff';
    a.phase+=.03; const bob=Math.sin(a.phase)*2*RENDER.scale, flick=.6+.4*Math.sin(a.phase*3);
    let fs=Math.max(12,Math.round(14*RENDER.scale)); octx.font=`${fs}px monospace`;
    const maxW=Math.round(120*RENDER.scale); while(octx.measureText(a.text).width>maxW && fs>9){ fs--; octx.font=`${fs}px monospace`; }
    octx.globalAlpha=.62; octx.save(); octx.shadowBlur=0; octx.fillStyle='rgba(0,0,0,.35)'; octx.fillText(a.text,sx+1,sy+bob+1); octx.restore();
    octx.shadowColor=color; octx.shadowBlur=14*flick; octx.fillStyle=color; octx.fillText(a.text,sx,sy+bob);
    octx.globalAlpha=1;
  }
  octx.restore();
}

function blit(){
  gctx.clearRect(0,0,gameCanvas.width,gameCanvas.height);
  const s=Math.min(gameCanvas.width/VW, gameCanvas.height/VH);
  const sw=(VW*s)|0, sh=(VH*s)|0, ox=((gameCanvas.width-sw)/2)|0, oy=((gameCanvas.height-sh)/2)|0;
  gctx.drawImage(nes,0,0,VW,VH,ox,oy,sw,sh); RENDER={scale:s,ox,oy};
}

/* =========================================================
   RESET / BOOT / LOOP
========================================================= */
function reset(){
  gameState='playing'; cameraX=0; worldMaxX=0; score=0; level=1; justLeveled=0;
  platforms=[]; robots=[]; drones=[]; terminals=[]; ads=[]; generatedUntil=0;
  player=makePlayer();
  for(let x=0;x<CHUNK*4;x+=CHUNK) genChunk(x);
  resetBtn.style.display='none';
}

async function boot(){
  SPR = await loadSprites(SPRITE_DEF);
  bgFar=SPR.bg.far; bgMid=SPR.bg.mid; bgNear=SPR.bg.near; fgRail=SPR.bg.rail;
  // Initialize anim runners
  setAnim(player=makePlayer(),'player','idle');
  for(let x=0;x<CHUNK*4;x+=CHUNK) genChunk(x);
  gameState='playing';
}
boot();

function loop(now){
  const dt=loop.t?now-loop.t:16; loop.t=now;
  if(gameState==='playing') update(dt,now);

  // DRAW
  ctx.fillStyle='#000'; ctx.fillRect(0,0,VW,VH);
  if(bgFar) { drawParallax(); } else { drawSky(); } // fallback gradient if no bg
  drawTiles(); drawTerminals(); drawEntities(now); drawUI(now);
  blit(); drawOverlay(now);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blackout Protocol - Cyberpunk Rebel</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #000;
      color: #ff3366;
      font-family: 'Courier New', monospace;
      overflow-x: hidden;
    }

    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      padding-top: 100%; /* 1x1 ratio */
      background: black;
      border: 2px solid #ff3366;
      box-shadow: 0 0 20px rgba(255, 51, 102, 0.3);
    }

    #gameCanvas {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.6));
      cursor: crosshair;
    }

    .controls {
      text-align: center;
      margin: 20px 0;
      color: #ff3366;
    }

    .back-button {
      display: inline-block;
      margin: 20px auto;
      padding: 12px 24px;
      background: rgba(0, 0, 0, 0.7);
      color: #ff3366;
      border: 2px solid #ff3366;
      text-decoration: none;
      border-radius: 6px;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .back-button:hover {
      background: rgba(255, 51, 102, 0.1);
      box-shadow: 0 0 15px rgba(255, 51, 102, 0.4);
      transform: translateY(-2px);
    }

    .game-title {
      text-align: center;
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <h1 class="game-title">Blackout Protocol</h1>
  
  <div class="controls">
    <p>Arrow Keys: Move | Space: Jump | Enter: Hack | ESC: Pause</p>
  </div>

  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
  </div>

  <div style="text-align: center; margin-top: 20px;">
    <a href="../games-list" class="back-button">Return to Games</a>
  </div>

  <script>
    // Game Canvas Setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas resolution
    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game State
    let gameState = 'playing'; // playing, paused, gameOver
    let score = 0;
    let level = 1;
    let worldOffset = 0; // Track how far right the player has traveled
    let difficultyLevel = 1;
    let lastEnemySpawn = 0;
    let lastDroneSpawn = 0;
    
    // Player Object
    const player = {
      x: 50,
      y: 200,
      width: 20,
      height: 30,
      velocityX: 0,
      velocityY: 0,
      speed: 4,
      jumpPower: 12,
      onGround: false,
      health: 100,
      color: '#00ffcc',
      totalDistanceTraveled: 0
    };

    // Game Objects Arrays
    let platforms = [];
    let enemies = [];
    let drones = [];
    let cameras = [];
    let hackItems = [];
    let particles = [];
    
    // Background layers for parallax effect
    let backgroundLayers = [];

    // Input Handling
    const keys = {};
    
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      
      if (e.code === 'Escape') {
        gameState = gameState === 'playing' ? 'paused' : 'playing';
      }
      
      if (e.code === 'Enter' && gameState === 'playing') {
        hackNearbyCamera();
      }
    });
    
    document.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    // Initialize Game World
    function initGame() {
      // Create initial platforms (more will be generated as player progresses)
      platforms = [
        {x: 0, y: canvas.height - 40, width: canvas.width * 10, height: 40}, // extended ground
        {x: 200, y: canvas.height - 120, width: 150, height: 20},
        {x: 400, y: canvas.height - 200, width: 120, height: 20},
        {x: 600, y: canvas.height - 160, width: 100, height: 20},
        {x: 100, y: canvas.height - 280, width: 180, height: 20}
      ];

      // Create initial enemies
      enemies = [
        {x: 300, y: canvas.height - 70, width: 15, height: 25, direction: 1, speed: 1, patrolStart: 250, patrolEnd: 400, health: 2, isChasing: false, lastPlayerSeen: {x: 0, y: 0}},
        {x: 500, y: canvas.height - 230, width: 15, height: 25, direction: 1, speed: 1.5, patrolStart: 450, patrolEnd: 550, health: 2, isChasing: false, lastPlayerSeen: {x: 0, y: 0}},
        {x: 650, y: canvas.height - 190, width: 15, height: 25, direction: -1, speed: 1, patrolStart: 600, patrolEnd: 720, health: 2, isChasing: false, lastPlayerSeen: {x: 0, y: 0}}
      ];

      // Create initial drones
      drones = [
        {x: 150, y: 100, width: 25, height: 15, direction: 1, speed: 2, patrolStart: 100, patrolEnd: 300, isChasing: false, alertLevel: 0},
        {x: 450, y: 150, width: 25, height: 15, direction: -1, speed: 1.5, patrolStart: 400, patrolEnd: 600, isChasing: false, alertLevel: 0}
      ];

      // Create cameras
      cameras = [
        {x: 350, y: canvas.height - 250, width: 20, height: 15, active: true, detectionRange: 80, hacked: false, alertedEnemies: false},
        {x: 550, y: canvas.height - 300, width: 20, height: 15, active: true, detectionRange: 100, hacked: false, alertedEnemies: false}
      ];

      // Create hack items
      hackItems = [
        {x: 250, y: canvas.height - 140, width: 12, height: 12, collected: false},
        {x: 450, y: canvas.height - 220, width: 12, height: 12, collected: false},
        {x: 150, y: canvas.height - 300, width: 12, height: 12, collected: false}
      ];

      generateBackgroundLayers();
    }

    // Generate dynamic background layers
    function generateBackgroundLayers() {
      backgroundLayers = [];
      for (let layer = 0; layer < 3; layer++) {
        backgroundLayers.push({
          buildings: generateBuildings(layer),
          parallaxSpeed: 0.1 + layer * 0.2,
          opacity: 0.3 + layer * 0.2
        });
      }
    }

    function generateBuildings(layer) {
      const buildings = [];
      const buildingCount = 20 + layer * 10;
      for (let i = 0; i < buildingCount; i++) {
        buildings.push({
          x: i * (100 + Math.random() * 50),
          y: canvas.height - (100 + Math.random() * 200 + layer * 50),
          width: 30 + Math.random() * 40,
          height: 100 + Math.random() * 200 + layer * 50,
          windows: Math.floor(Math.random() * 8) + 2,
          color: layer === 0 ? '#111' : (layer === 1 ? '#222' : '#333')
        });
      }
      return buildings;
    }

    // Spawn new enemies as player progresses
    function spawnEnemies() {
      const currentDistance = player.totalDistanceTraveled;
      if (currentDistance > lastEnemySpawn + (1000 / difficultyLevel)) {
        const spawnX = player.x + canvas.width + Math.random() * 200;
        enemies.push({
          x: spawnX,
          y: canvas.height - 70,
          width: 15,
          height: 25,
          direction: -1,
          speed: 1 + Math.random() * difficultyLevel * 0.5,
          patrolStart: spawnX - 100,
          patrolEnd: spawnX + 100,
          health: 2 + Math.floor(difficultyLevel / 3),
          isChasing: false,
          lastPlayerSeen: {x: 0, y: 0}
        });
        lastEnemySpawn = currentDistance;
      }
    }

    // Spawn new drones as player progresses
    function spawnDrones() {
      const currentDistance = player.totalDistanceTraveled;
      if (currentDistance > lastDroneSpawn + (1500 / difficultyLevel)) {
        const spawnX = player.x + canvas.width + Math.random() * 300;
        drones.push({
          x: spawnX,
          y: 50 + Math.random() * 150,
          width: 25,
          height: 15,
          direction: -1,
          speed: 2 + Math.random() * difficultyLevel * 0.3,
          patrolStart: spawnX - 150,
          patrolEnd: spawnX + 150,
          isChasing: false,
          alertLevel: 0
        });
        lastDroneSpawn = currentDistance;
      }
    }

    // Game Physics
    function updatePlayer() {
      if (gameState !== 'playing') return;

      const previousX = player.x;

      // Horizontal movement
      if (keys['ArrowLeft']) {
        player.velocityX = -player.speed;
      } else if (keys['ArrowRight']) {
        player.velocityX = player.speed;
      } else {
        player.velocityX *= 0.8; // friction
      }

      // Jumping
      if (keys['Space'] && player.onGround) {
        player.velocityY = -player.jumpPower;
        player.onGround = false;
      }

      // Gravity
      player.velocityY += 0.6;
      if (player.velocityY > 15) player.velocityY = 15;

      // Update position
      player.x += player.velocityX;
      player.y += player.velocityY;

      // Track total distance traveled
      if (player.x > previousX) {
        player.totalDistanceTraveled += (player.x - previousX);
        
        // Update difficulty level based on distance
        const newDifficultyLevel = Math.floor(player.totalDistanceTraveled / 1000) + 1;
        if (newDifficultyLevel > difficultyLevel) {
          difficultyLevel = newDifficultyLevel;
          level = difficultyLevel;
        }
      }

      // Platform collision
      player.onGround = false;
      platforms.forEach(platform => {
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y < platform.y + platform.height &&
            player.y + player.height > platform.y) {
          
          if (player.velocityY > 0 && player.y < platform.y) {
            player.y = platform.y - player.height;
            player.velocityY = 0;
            player.onGround = true;
          }
        }
      });

      // Keep player in bounds
      if (player.x < 0) player.x = 0;
      if (player.y > canvas.height) {
        player.health -= 20;
        player.x = 50;
        player.y = 200;
        if (player.health <= 0) gameState = 'gameOver';
      }

      // Spawn new enemies and drones based on progression
      spawnEnemies();
      spawnDrones();
    }

    function updateEnemies() {
      if (gameState !== 'playing') return;

      enemies.forEach((enemy, index) => {
        if (enemy.health <= 0) {
          enemies.splice(index, 1);
          score += 10;
          return;
        }

        // Check if enemy can see player
        const distanceToPlayer = Math.sqrt(
          Math.pow(player.x - enemy.x, 2) + Math.pow(player.y - enemy.y, 2)
        );

        // Chasing behavior
        if (distanceToPlayer < 150 && !enemy.isChasing) {
          enemy.isChasing = true;
          enemy.lastPlayerSeen = {x: player.x, y: player.y};
        }

        if (enemy.isChasing) {
          // Chase the player or last known position
          const targetX = distanceToPlayer < 200 ? player.x : enemy.lastPlayerSeen.x;
          
          if (targetX > enemy.x + enemy.width/2) {
            enemy.direction = 1;
          } else if (targetX < enemy.x + enemy.width/2) {
            enemy.direction = -1;
          }

          enemy.x += enemy.direction * (enemy.speed * 1.5); // Faster when chasing

          // Stop chasing if too far from last known position
          if (Math.abs(enemy.x - enemy.lastPlayerSeen.x) > 300) {
            enemy.isChasing = false;
          }
        } else {
          // Normal patrol movement
          enemy.x += enemy.direction * enemy.speed;
          
          if (enemy.x <= enemy.patrolStart || enemy.x >= enemy.patrolEnd) {
            enemy.direction *= -1;
          }
        }

        // Check collision with player
        if (player.x < enemy.x + enemy.width &&
            player.x + player.width > enemy.x &&
            player.y < enemy.y + enemy.height &&
            player.y + player.height > enemy.y) {
          
          if (player.velocityY > 0 && player.y < enemy.y) {
            // Player jumped on enemy
            enemy.health--;
            player.velocityY = -8;
            createParticles(enemy.x + enemy.width/2, enemy.y, '#ff3366');
          } else {
            // Player hit enemy
            player.health -= 5 + Math.floor(difficultyLevel / 2);
            player.velocityX = (player.x < enemy.x) ? -8 : 8;
            if (player.health <= 0) gameState = 'gameOver';
          }
        }
      });
    }

    function updateDrones() {
      if (gameState !== 'playing') return;

      drones.forEach((drone, index) => {
        // Remove drones that are too far behind the player
        if (drone.x < player.x - canvas.width * 2) {
          drones.splice(index, 1);
          return;
        }

        const distanceToPlayer = Math.sqrt(
          Math.pow(player.x - drone.x, 2) + Math.pow(player.y - drone.y, 2)
        );

        // Alert behavior - drones get more aggressive when they detect player
        if (distanceToPlayer < 120) {
          drone.alertLevel = Math.min(drone.alertLevel + 0.02, 1);
          drone.isChasing = true;
        } else if (drone.alertLevel > 0) {
          drone.alertLevel = Math.max(drone.alertLevel - 0.01, 0);
          if (drone.alertLevel <= 0) {
            drone.isChasing = false;
          }
        }

        if (drone.isChasing && distanceToPlayer < 200) {
          // Chase the player
          const targetX = player.x + player.width/2;
          const targetY = player.y + player.height/2;
          
          const deltaX = targetX - (drone.x + drone.width/2);
          const deltaY = targetY - (drone.y + drone.height/2);
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          
          if (distance > 0) {
            drone.x += (deltaX / distance) * drone.speed * (1 + drone.alertLevel);
            drone.y += (deltaY / distance) * drone.speed * 0.5 * (1 + drone.alertLevel);
          }
        } else {
          // Normal patrol movement
          drone.x += drone.direction * drone.speed;
          
          if (drone.x <= drone.patrolStart || drone.x >= drone.patrolEnd) {
            drone.direction *= -1;
          }
        }

        // Check collision with player
        if (player.x < drone.x + drone.width &&
            player.x + player.width > drone.x &&
            player.y < drone.y + drone.height &&
            player.y + player.height > drone.y) {
          
          player.health -= 3 + Math.floor(difficultyLevel / 2);
          createParticles(drone.x + drone.width/2, drone.y + drone.height/2, '#ffff00');
          if (player.health <= 0) gameState = 'gameOver';
        }
      });
    }

    function updateCameras() {
      if (gameState !== 'playing') return;

      cameras.forEach(camera => {
        if (camera.hacked) return;

        const distanceToPlayer = Math.sqrt(
          Math.pow(player.x - camera.x, 2) + Math.pow(player.y - camera.y, 2)
        );

        if (distanceToPlayer < camera.detectionRange) {
          camera.active = true;
          
          // Alert nearby enemies and drones when player is spotted
          if (!camera.alertedEnemies) {
            enemies.forEach(enemy => {
              const enemyDistance = Math.sqrt(
                Math.pow(enemy.x - camera.x, 2) + Math.pow(enemy.y - camera.y, 2)
              );
              if (enemyDistance < 300) {
                enemy.isChasing = true;
                enemy.lastPlayerSeen = {x: player.x, y: player.y};
              }
            });

            drones.forEach(drone => {
              const droneDistance = Math.sqrt(
                Math.pow(drone.x - camera.x, 2) + Math.pow(drone.y - camera.y, 2)
              );
              if (droneDistance < 400) {
                drone.isChasing = true;
                drone.alertLevel = 1;
              }
            });
            
            camera.alertedEnemies = true;
          }
          
          // Camera spotted player - reduce health slowly
          if (Math.random() < 0.02) {
            player.health -= 1;
            if (player.health <= 0) gameState = 'gameOver';
          }
        } else {
          camera.alertedEnemies = false;
        }
      });
    }

    function updateHackItems() {
      if (gameState !== 'playing') return;

      hackItems.forEach(item => {
        if (item.collected) return;

        if (player.x < item.x + item.width &&
            player.x + player.width > item.x &&
            player.y < item.y + item.height &&
            player.y + player.height > item.y) {
          
          item.collected = true;
          score += 5;
          player.health = Math.min(100, player.health + 10);
          createParticles(item.x + item.width/2, item.y + item.height/2, '#00ffcc');
        }
      });
    }

    function hackNearbyCamera() {
      cameras.forEach(camera => {
        const distanceToPlayer = Math.sqrt(
          Math.pow(player.x - camera.x, 2) + Math.pow(player.y - camera.y, 2)
        );

        if (distanceToPlayer < 50) {
          camera.hacked = true;
          camera.active = false;
          score += 20;
          createParticles(camera.x + camera.width/2, camera.y + camera.height/2, '#00ff00');
        }
      });
    }

    function createParticles(x, y, color) {
      for (let i = 0; i < 8; i++) {
        particles.push({
          x: x,
          y: y,
          velocityX: (Math.random() - 0.5) * 8,
          velocityY: (Math.random() - 0.5) * 8,
          life: 30,
          color: color
        });
      }
    }

    function updateParticles() {
      particles.forEach((particle, index) => {
        particle.x += particle.velocityX;
        particle.y += particle.velocityY;
        particle.life--;
        
        if (particle.life <= 0) {
          particles.splice(index, 1);
        }
      });
    }

    // Rendering Functions
    function drawBackground() {
      // Dynamic background with parallax layers
      backgroundLayers.forEach((layer, layerIndex) => {
        ctx.fillStyle = layer.color || '#000';
        ctx.globalAlpha = layer.opacity;
        
        layer.buildings.forEach(building => {
          const offsetX = (player.totalDistanceTraveled * layer.parallaxSpeed) % (canvas.width * 2);
          const drawX = building.x - offsetX;
          
          // Only draw buildings that are visible
          if (drawX + building.width > -100 && drawX < canvas.width + 100) {
            // Building body
            ctx.fillStyle = building.color;
            ctx.fillRect(drawX, building.y, building.width, building.height);
            
            // Windows based on difficulty level (more lit windows = more danger)
            const windowsLit = Math.min(building.windows, Math.floor(difficultyLevel / 2) + 1);
            for (let w = 0; w < windowsLit; w++) {
              const windowX = drawX + 5 + (w % 3) * (building.width / 3 - 5);
              const windowY = building.y + 10 + Math.floor(w / 3) * 25;
              
              // Different window colors based on layer and difficulty
              if (layerIndex === 0) {
                ctx.fillStyle = difficultyLevel > 3 ? '#ff3366' : '#ffff00';
              } else if (layerIndex === 1) {
                ctx.fillStyle = difficultyLevel > 5 ? '#ff6633' : '#00ffcc';
              } else {
                ctx.fillStyle = '#ffffff';
              }
              
              ctx.fillRect(windowX, windowY, 8, 12);
            }
            
            // Add some cyberpunk details for higher difficulty
            if (difficultyLevel > 2 && layerIndex === 0) {
              // Neon signs
              ctx.fillStyle = '#ff00ff';
              ctx.fillRect(drawX, building.y + building.height - 30, building.width, 4);
              
              // Antenna/communication arrays
              if (Math.random() < 0.3) {
                ctx.strokeStyle = '#00ffcc';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(drawX + building.width/2, building.y);
                ctx.lineTo(drawX + building.width/2, building.y - 20);
                ctx.stroke();
              }
            }
          }
        });
        
        ctx.globalAlpha = 1;
      });
    }

    function drawPlayer() {
      const x = player.x;
      const y = player.y;
      const scale = player.width / 20; // Scale factor based on player width
      
      // Player glow effect
      ctx.shadowBlur = 8;
      ctx.shadowColor = player.color;
      
      // Head
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.arc(x + 10 * scale, y + 6 * scale, 5 * scale, 0, Math.PI * 2);
      ctx.fill();
      
      // Body (torso)
      ctx.fillStyle = player.color;
      ctx.fillRect(x + 7 * scale, y + 10 * scale, 6 * scale, 12 * scale);
      
      // Arms
      ctx.fillStyle = player.color;
      // Left arm
      ctx.fillRect(x + 4 * scale, y + 12 * scale, 3 * scale, 8 * scale);
      // Right arm  
      ctx.fillRect(x + 13 * scale, y + 12 * scale, 3 * scale, 8 * scale);
      
      // Legs
      ctx.fillStyle = player.color;
      // Left leg
      ctx.fillRect(x + 7 * scale, y + 22 * scale, 2.5 * scale, 8 * scale);
      // Right leg
      ctx.fillRect(x + 10.5 * scale, y + 22 * scale, 2.5 * scale, 8 * scale);
      
      // Add some cyberpunk details
      ctx.fillStyle = '#ffffff';
      // Eyes (white dots)
      ctx.fillRect(x + 8 * scale, y + 5 * scale, 1 * scale, 1 * scale);
      ctx.fillRect(x + 11 * scale, y + 5 * scale, 1 * scale, 1 * scale);
      
      // Chest detail (glowing core)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x + 9 * scale, y + 15 * scale, 2 * scale, 2 * scale);
      
      ctx.shadowBlur = 0;
    }

    function drawPlatforms() {
      ctx.fillStyle = '#333';
      platforms.forEach(platform => {
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        
        // Platform edge glow
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
      });
    }

    function drawEnemies() {
      enemies.forEach(enemy => {
        const x = enemy.x;
        const y = enemy.y;
        const scale = enemy.width / 15; // Scale factor based on enemy width
        
        // Robot glow effect
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#ff3366';
        
        // Robot head (rectangular with antenna)
        ctx.fillStyle = '#ff3366';
        ctx.fillRect(x + 4 * scale, y, 7 * scale, 6 * scale);
        
        // Head details - glowing eyes
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x + 5 * scale, y + 1.5 * scale, 1.5 * scale, 1.5 * scale);
        ctx.fillRect(x + 8.5 * scale, y + 1.5 * scale, 1.5 * scale, 1.5 * scale);
        
        // Antenna
        ctx.fillStyle = '#ff3366';
        ctx.fillRect(x + 7 * scale, y - 2 * scale, 1 * scale, 3 * scale);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x + 6.5 * scale, y - 2 * scale, 2 * scale, 1 * scale);
        
        // Robot torso (main body)
        ctx.fillStyle = '#ff3366';
        ctx.fillRect(x + 3 * scale, y + 6 * scale, 9 * scale, 12 * scale);
        
        // Chest panel detail
        ctx.fillStyle = '#990033';
        ctx.fillRect(x + 4 * scale, y + 8 * scale, 7 * scale, 8 * scale);
        
        // Central power core (glowing)
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x + 6.5 * scale, y + 10 * scale, 2 * scale, 4 * scale);
        
        // Robot arms
        ctx.fillStyle = '#ff3366';
        // Left arm
        ctx.fillRect(x, y + 8 * scale, 3 * scale, 8 * scale);
        // Right arm  
        ctx.fillRect(x + 12 * scale, y + 8 * scale, 3 * scale, 8 * scale);
        
        // Shoulder joints
        ctx.fillStyle = '#990033';
        ctx.fillRect(x + 2.5 * scale, y + 7 * scale, 2 * scale, 2 * scale);
        ctx.fillRect(x + 10.5 * scale, y + 7 * scale, 2 * scale, 2 * scale);
        
        // Robot legs
        ctx.fillStyle = '#ff3366';
        // Left leg
        ctx.fillRect(x + 4 * scale, y + 18 * scale, 3 * scale, 7 * scale);
        // Right leg
        ctx.fillRect(x + 8 * scale, y + 18 * scale, 3 * scale, 7 * scale);
        
        // Knee joints
        ctx.fillStyle = '#990033';
        ctx.fillRect(x + 4.5 * scale, y + 20 * scale, 2 * scale, 1 * scale);
        ctx.fillRect(x + 8.5 * scale, y + 20 * scale, 2 * scale, 1 * scale);
        
        // Robot feet
        ctx.fillStyle = '#ff3366';
        ctx.fillRect(x + 3.5 * scale, y + 25 * scale, 4 * scale, 2 * scale);
        ctx.fillRect(x + 7.5 * scale, y + 25 * scale, 4 * scale, 2 * scale);
        
        // Add some tech details - circuit lines
        ctx.strokeStyle = '#990033';
        ctx.lineWidth = 1;
        ctx.beginPath();
        // Vertical lines on torso
        ctx.moveTo(x + 5 * scale, y + 8 * scale);
        ctx.lineTo(x + 5 * scale, y + 16 * scale);
        ctx.moveTo(x + 10 * scale, y + 8 * scale);
        ctx.lineTo(x + 10 * scale, y + 16 * scale);
        // Horizontal line across chest
        ctx.moveTo(x + 4 * scale, y + 12 * scale);
        ctx.lineTo(x + 11 * scale, y + 12 * scale);
        ctx.stroke();
        
        ctx.shadowBlur = 0;
      });
    }

    function drawDrones() {
      drones.forEach(drone => {
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(drone.x, drone.y, drone.width, drone.height);
        
        // Drone glow and propellers
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#ffff00';
        ctx.fillRect(drone.x, drone.y, drone.width, drone.height);
        ctx.shadowBlur = 0;
        
        // Simple propeller lines
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(drone.x - 5, drone.y + drone.height/2);
        ctx.lineTo(drone.x + drone.width + 5, drone.y + drone.height/2);
        ctx.stroke();
      });
    }

    function drawCameras() {
      cameras.forEach(camera => {
        if (camera.hacked) {
          ctx.fillStyle = '#00ff00';
        } else if (camera.active) {
          ctx.fillStyle = '#ff0000';
        } else {
          ctx.fillStyle = '#888';
        }
        
        ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
        
        // Camera detection cone
        if (!camera.hacked && camera.active) {
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(camera.x + camera.width/2, camera.y + camera.height/2, camera.detectionRange, 0, Math.PI * 2);
          ctx.stroke();
        }
      });
    }

    function drawHackItems() {
      hackItems.forEach(item => {
        if (item.collected) return;
        
        ctx.fillStyle = '#00ffcc';
        ctx.fillRect(item.x, item.y, item.width, item.height);
        
        // Hack item glow
        ctx.shadowBlur = 6;
        ctx.shadowColor = '#00ffcc';
        ctx.fillRect(item.x, item.y, item.width, item.height);
        ctx.shadowBlur = 0;
      });
    }

    function drawParticles() {
      particles.forEach(particle => {
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = particle.life / 30;
        ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
        ctx.globalAlpha = 1;
      });
    }

    function drawUI() {
      ctx.fillStyle = '#ff3366';
      ctx.font = '16px Courier New';
      ctx.fillText(`Health: ${player.health}`, 10, 25);
      ctx.fillText(`Score: ${score}`, 10, 45);
      ctx.fillText(`Difficulty: ${difficultyLevel}`, 10, 65);
      ctx.fillText(`Distance: ${Math.floor(player.totalDistanceTraveled)}m`, 10, 85);
      ctx.fillText(`Enemies: ${enemies.length} | Drones: ${drones.length}`, 10, 105);
      
      if (gameState === 'paused') {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ff3366';
        ctx.font = '32px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
        ctx.font = '16px Courier New';
        ctx.fillText('Press ESC to continue', canvas.width/2, canvas.height/2 + 40);
        ctx.textAlign = 'left';
      }
      
      if (gameState === 'gameOver') {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ff3366';
        ctx.font = '32px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
        ctx.font = '16px Courier New';
        ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + 40);
        ctx.fillText('Refresh to restart', canvas.width/2, canvas.height/2 + 60);
        ctx.textAlign = 'left';
      }
    }

    // Main Game Loop
    function gameLoop() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update game objects
      updatePlayer();
      updateEnemies();
      updateDrones();
      updateCameras();
      updateHackItems();
      updateParticles();
      
      // Draw everything
      drawBackground();
      drawPlatforms();
      drawPlayer();
      drawEnemies();
      drawDrones();
      drawCameras();
      drawHackItems();
      drawParticles();
      drawUI();
      
      // Continue loop
      requestAnimationFrame(gameLoop);
    }

    // Start the game
    initGame();
    gameLoop();
  </script>
</body>
</html>

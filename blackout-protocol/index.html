<!DOCTYPE html>
<html lang="en">
<head>
  <base href="/blackout-protocol/">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Blackout Protocol — Web Build</title>
  <style>
    :root { --frame-w: 960px; }
    html,body{margin:0;background:#000;color:#cfd6df;font-family:monospace;overflow:hidden;}
    #gameContainer{position:relative;width:100%;max-width:var(--frame-w);margin:0 auto;aspect-ratio:4/3;background:#000;border:2px solid #5c5c5c;}
    canvas{position:absolute;inset:0;display:block;image-rendering:pixelated;image-rendering:crisp-edges;}
    #overlayCanvas{pointer-events:none;}
    #resetBtn{position:absolute;left:50%;top:50%;transform:translate(-50%,-8px);padding:10px 16px;background:#0f1016;border:2px solid #626a78;border-radius:6px;color:#cfd6df;letter-spacing:.6px;display:none;cursor:pointer;z-index:5}
    #resetBtn:hover{filter:brightness(1.15)}
  </style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <canvas id="overlayCanvas"></canvas>
  <button id="resetBtn" type="button">Reset (R)</button>
</div>

<script>
/* ================= CONFIG ================= */
const SHOP_URL = './game-shop.html';
const VW=960, VH=720;
const TILE = 48;            // tile size
const LEVEL_LEN = 1900;     // door at far-right
const DOOR_W = 24, DOOR_H = 32;
const HYPER_RELOAD_TAG = 'rev=' + Date.now();

/* ================= RENDER TARGETS ================= */
let gcanvas, gctx;                    // on-screen canvas + ctx
const nes = document.createElement('canvas');  // offscreen buffer
nes.width = VW; nes.height = VH;
const nesCtx = nes.getContext('2d', { alpha:false }); // <-- renamed to avoid conflicts
nesCtx.imageSmoothingEnabled = false;
nesCtx.font = '9px monospace';
nesCtx.textBaseline = 'top';

let overlayCanvas, octx;
let RENDER={scale:1,ox:0,oy:0};
function fit(){
  const r=document.getElementById('gameContainer').getBoundingClientRect();
  gcanvas.width=r.width; gcanvas.height=r.height;
  overlayCanvas.width=r.width; overlayCanvas.height=r.height;
}
addEventListener('resize',fit);

/* ================= CORE / STATE ================= */
let READY=false, LOAD_MSG='Loading…';
let currentLevel=1, score=0, btc=0;
let empGrenades=3, hasDoubleJump=false, hasArmor=false, hasMedkits=false, medkitCount=0;
let gameState='loading';
let cameraX=0, worldMaxX=0;

/* ================= SESSION STORAGE (per run) ================= */
function getN(k,d){ const n=parseInt(sessionStorage.getItem(k)||''); return Number.isFinite(n)?n:d; }
function setN(k,v){ sessionStorage.setItem(k,String(v)); }
function getO(k){ try{ return JSON.parse(sessionStorage.getItem(k)||'{}'); }catch{ return {}; } }
function setO(k,v){ sessionStorage.setItem(k, JSON.stringify(v)); }

function getLevel(){ return Math.max(1, getN('gameLevel', 1)); }
function setLevel(n){ setN('gameLevel', Math.max(1,n)); }

function clearRun(){
  try{
    sessionStorage.removeItem('playerBTC');
    sessionStorage.removeItem('playerScore');
    sessionStorage.removeItem('playerHealth');
    sessionStorage.setItem('bp_session_started','1');
  }catch{}
}

/* ================= INPUT ================= */
const keys={}, JUMP_BUFFER=140, COYOTE=140;
let jumpBufferUntil=0, coyoteUntil=0, jumpHeld=false;

addEventListener('keydown',e=>{
  if(['Space','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.code)) e.preventDefault();
  keys[e.code]=true;
  if(e.code==='Escape') gameState=(gameState==='playing')?'paused':(gameState==='paused'?'playing':gameState);
  if(e.code==='Space'){ jumpBufferUntil=performance.now()+JUMP_BUFFER; jumpHeld=true; }
  if(e.code==='KeyE' && gameState==='playing') tryMobileEMP();
  if(e.code==='KeyR' && (gameState==='gameOver'||gameState==='levelComplete')) hardResetToL1();
  if(e.code==='Enter' && gameState==='playing') tryHack();
},{passive:false});
addEventListener('keyup',e=>{ keys[e.code]=false; if(e.code==='Space') jumpHeld=false; });

/* ================= BACKGROUNDS ================= */
const BG={far:null, near:null};
const PARALLAX={far:0.18, near:0.55};
const NEAR_FADE_PX=120;

function levelSuffix(lv){ return lv<10 ? `0${lv}` : String(lv); }
function levelArt(lv){
  const s = levelSuffix(lv);
  return {
    bg_far:  `assets/${s}_bg_far.png?${HYPER_RELOAD_TAG}`,
    bg_near: `assets/${s}_bg_near.png?${HYPER_RELOAD_TAG}`,
  };
}

const IMG = (path) => new Promise(resolve=>{
  if(!path){ resolve(null); return; }
  const i=new Image();
  i.onload=()=>resolve(i);
  i.onerror=()=>{ console.error('✗ Failed to load asset:', path); resolve(null); };
  i.src=path;
});

async function loadBackgroundsForLevel(lv){
  const art = levelArt(lv);
  BG.far  = await IMG(art.bg_far);
  BG.near = await IMG(art.bg_near);
}
function tileParallax(img, speed){
  if(!img) return;
  const ctx = nesCtx;
  const scale = VH / img.height;
  const tileW = Math.max(1, Math.round(img.width * scale));
  const cam = cameraX||0;
  let x = -Math.floor((cam*speed) % tileW);
  if (x>0) x -= tileW;
  for(let i=0;i<4;i++){
    const drawX = x + i*tileW;
    const flip = (i%2)===1;
    ctx.save();
    if(flip){
      ctx.translate(drawX + tileW, 0);
      ctx.scale(-1,1);
      ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, tileW, VH);
    }else{
      ctx.drawImage(img, 0, 0, img.width, img.height, drawX, 0, tileW, VH);
    }
    ctx.restore();
  }
}
function drawBackgrounds(){
  const ctx = nesCtx;
  if(!BG.far && !BG.near){
    for(let y=0;y<VH;y++){
      const t=y/VH; ctx.fillStyle=`rgb(${12+18*t|0},${16+30*t|0},${30+58*t|0})`;
      ctx.fillRect(0,y,VW,1);
    }
    return;
  }
  if(BG.far)  tileParallax(BG.far,  PARALLAX.far);
  if(BG.near){
    ctx.save();
    tileParallax(BG.near, PARALLAX.near);
    const fadeH=Math.min(NEAR_FADE_PX,VH);
    const g=nesCtx.createLinearGradient(0,0,0,fadeH);
    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,1)');
    nesCtx.globalCompositeOperation='destination-in';
    nesCtx.fillStyle=g; nesCtx.fillRect(0,0,VW,VH);
    nesCtx.restore();
  }
}

/* ================= SPRITES ================= */
const SPRITE_DEF={
  player:{fw:48,fh:48, states:{
    idle:'assets/player_idle_48.png', walk:'assets/player_walk_48.png', run:'assets/player_run_48.png',
    jump:'assets/player_jump_48.png', fall:'assets/player_fall_48.png', hurt:'assets/player_hurt_48.png', dead:'assets/player_dead_48.png'
  }, fps:{idle:6, walk:10, run:12, jump:10, fall:10, hurt:6, dead:8}},
  robot:{fw:48,fh:48, states:{
    idle:'assets/robot_idle_48.png', walk:'assets/robot_walk_48.png', run:'assets/robot_run_48.png',
    attack:'assets/robot_attack_48.png', hurt:'assets/robot_hurt_48.png', dead:'assets/robot_dead_48.png'
  }, fps:{idle:6, walk:9, run:10, attack:12, hurt:6, dead:8}},
  drone:{fw:32,fh:32, states:{
    idle:'assets/drone_idle_32.png', hover:'assets/drone_hover_32.png', move:'assets/drone_move_32.png',
    attack:'assets/drone_attack_32.png', hurt:'assets/drone_hurt_32.png', dead:'assets/drone_dead_32.png'
  }, fps:{idle:3, hover:10, move:10, attack:12, hurt:6, dead:8}},
  female:{fw:48,fh:48, states:{
    idle:'assets/female_idle.png',
    run:'assets/female_run.png'
  }, fps:{idle:6, run:10}}
};

let SPR=null;
function makeAnimator(sheet, fw, fh, fps){
  const frames = sheet ? Math.max(1, Math.floor(sheet.width / fw)) : 1;
  let frame=0, time=0, spf=1000/(fps||8);
  return {
    reset(){ frame=0; time=0; },
    step(dt, clamp=false){ time+=dt; while(time>spf){ time-=spf; frame = clamp ? Math.min(frame+1, frames-1) : (frame+1)%frames; } },
    draw(x,y,flip=false,alpha=1){
      if(!sheet) return;
      const sx=frame*fw;
      nesCtx.save(); nesCtx.globalAlpha=alpha;
      if(flip){ nesCtx.translate(x+fw,y); nesCtx.scale(-1,1); nesCtx.drawImage(sheet,sx,0,fw,fh,0,0,fw,fh); }
      else    { nesCtx.drawImage(sheet,sx,0,fw,fh,x,y,fw,fh); }
      nesCtx.restore();
    }
  };
}
async function loadSprites(def){
  const out={};
  for(const who of Object.keys(def)){
    const entry = def[who];
    const fw=entry.fw, fh=entry.fh;
    const pack={fw,fh,anim:{},fps:entry.fps};
    for(const [state,src] of Object.entries(entry.states)){
      const img=await IMG(src);
      pack.anim[state]={img, make:()=>makeAnimator(img,fw,fh, entry.fps[state]||8)};
    }
    out[who]=pack;
  }
  return out;
}

/* ================= ADS ================= */
const AD_SRC_ALL = {
  Blackrock:`assets/Blackrock.png?${HYPER_RELOAD_TAG}`,
  Downthere:`assets/Downthere.png?${HYPER_RELOAD_TAG}`,
  Oxygen:`assets/Oxygen.png?${HYPER_RELOAD_TAG}`,
  Skinshift:`assets/Skinshift.png?${HYPER_RELOAD_TAG}`,
  Zen:`assets/Zen.png?${HYPER_RELOAD_TAG}`,
  Bug:`assets/Bug.png?${HYPER_RELOAD_TAG}`,
  Pill:`assets/Pill.png?${HYPER_RELOAD_TAG}`,
  Plug:`assets/Plug.png?${HYPER_RELOAD_TAG}`,
  Touchless:`assets/Touchless.png?${HYPER_RELOAD_TAG}`,
  Pinknoise:`assets/Pinknoise.png?${HYPER_RELOAD_TAG}`,
};
const ADS_BY_LEVEL = { 1:[], 2:['Blackrock','Downthere','Oxygen','Skinshift','Zen'], 3:['Bug','Pill','Plug','Touchless','Pinknoise'] };
let AdImages = {};
async function loadAdImages(lv){ AdImages={}; for(const k of (ADS_BY_LEVEL[lv]||[])){ AdImages[k]=await IMG(AD_SRC_ALL[k]); }}

/* ================= TILES / STATIC ================= */
let coinImg=null, doorImg=null, ledgeImg=null, platformImg=null, platformRailImg=null;
let terminalFrame1=null, terminalFrame2=null;

async function loadTiles(){
  coinImg     = await IMG(`assets/btc_glow.png?${HYPER_RELOAD_TAG}`);
  doorImg     = await IMG(`assets/shop_door_neon.png?${HYPER_RELOAD_TAG}`);
  ledgeImg    = await IMG(`assets/ledge_tile.png?${HYPER_RELOAD_TAG}`);
  platformImg = await IMG(`assets/platform_industrial.png?${HYPER_RELOAD_TAG}`);
  platformRailImg = await IMG(`assets/platform_rail.png?${HYPER_RELOAD_TAG}`);
  terminalFrame1 = await IMG(`assets/hacker_terminal_frame1.png?${HYPER_RELOAD_TAG}`);
  terminalFrame2 = await IMG(`assets/hacker_terminal_frame2.png?${HYPER_RELOAD_TAG}`);
}

/* ================= ENTITIES ================= */
let player, robots=[], drones=[], npcs=[], platforms=[], terminals=[], ads=[], coins=[];
let exitDoor=null;

function makePlayer(){
  const savedHealth = parseInt(sessionStorage.getItem('playerHealth')) || 100;
  const savedUpgrades = JSON.parse(sessionStorage.getItem('playerUpgrades') || '{}');
  const baseSpeed = 1.52;
  const baseJump  = 5.6;
  const speed = savedUpgrades.speedBoost ? baseSpeed * 1.3 : baseSpeed;
  const jump  = savedUpgrades.jumpBoost  ? baseJump  * 1.2 : baseJump;
  return { x:32, y:VH-80, w:18, h:28, vx:0, vy:0, onGround:false, facing:1,
           speed, aGround:.19, aAir:.12, dragG:.82, dragA:.986, jump,
           hp:savedHealth, hitUntil:0, anim:{state:'idle',runner:null},
           upgrades: savedUpgrades };
}
function setAnim(actor, who, state, clamp=false){
  if(actor.anim.state===state) return;
  actor.anim.state=state;
  const spec=SPR[who]?.anim?.[state];
  actor.anim.runner = spec ? spec.make() : null;
  if(actor.anim.runner) actor.anim.runner.reset();
  actor.anim.clamp=clamp;
}
function stepAnim(a,dt){ if(a.anim.runner) a.anim.runner.step(dt, a.anim.clamp); }

function rects(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }

/* ================= WORLD GEN ================= */
const choice = a => a[(Math.random()*a.length)|0];
let generatedUntil=0;
const groundY = () => VH-TILE;
const CHUNK=320;
const L1_GATE_X = 900;

function genChunk(startX){
  const endX=startX+CHUNK;
  const firstScreen = startX < VW;

  for(let x=startX;x<endX;x+=TILE) platforms.push({x,y:groundY(),w:TILE,h:TILE});

  if(firstScreen){ generatedUntil=endX; worldMaxX=Math.max(worldMaxX,endX); return; }

  const LOW_Y  = groundY() - TILE*3;
  const HIGH_Y = groundY() - TILE*5;

  const lowX  = (startX + 48 + Math.random()*(CHUNK-140))|0;
  const highX = Math.min(endX-60, lowX + TILE*(5 + ((Math.random()*2)|0)));

  const lowW  = TILE*(5 + ((Math.random()*2)|0));
  const highW = TILE*(4 + ((Math.random()*2)|0));

  platforms.push({x:lowX,  y:LOW_Y,  w:lowW,  h:TILE});
  platforms.push({x:highX, y:HIGH_Y, w:highW, h:TILE});

  const coinPts = [
    {x: lowX + 12, y: LOW_Y-22},
    {x: highX + 18, y: HIGH_Y-22},
    {x: (lowX+highX)/2, y: Math.min(LOW_Y, HIGH_Y)-26}
  ];
  for(const p of coinPts){ coins.push({x:p.x|0, y:Math.max(40,Math.min(VH-24,p.y))|0, r:10, taken:false}); }

  if(Math.random()<.5){
    const tx=startX+40+Math.random()*(CHUNK-80); let ty=VH-TILE*2;
    for(const p of platforms){ if(tx>=p.x-4 && tx<=p.x+p.w+4) ty=Math.min(ty,p.y-TILE); }
    terminals.push({x:tx|0,y:ty|0,w:12,h:16,cooldown:0});
  }

  const adKeys = ADS_BY_LEVEL[currentLevel]||[];
  if(adKeys.length){
    const ax=startX+60+Math.random()*(CHUNK-120), ay=VH-(120+((Math.random()*50)|0));
    const kind = choice(adKeys);
    ads.push({x:ax|0,y:ay|0,kind,phase:Math.random()*6});
  }

  if(currentLevel===1){
    if(endX >= L1_GATE_X){
      const rc=1+((Math.random()*2)|0);
      for(let i=0;i<rc;i++){
        const rx=startX+64+Math.random()*(CHUNK-128);
        robots.push(makeRobot(rx|0));
      }
    }
  }else if(currentLevel===2){
    const rc=1+((Math.random()*2)|0);
    for(let i=0;i<rc;i++){
      const rx=startX+64+Math.random()*(CHUNK-128);
      robots.push(makeRobot(rx|0));
    }
    if(Math.random()<.9){
      const dx=startX+80+Math.random()*(CHUNK-160), dy=50+Math.random()*90;
      drones.push(makeDrone(dx|0,dy|0));
    }
  }else if(currentLevel===3){
    if(Math.random()<.6){
      const nx=startX+80+Math.random()*(CHUNK-140);
      npcs.push(makeCollector(nx|0, VH-TILE*2));
    }
  }

  generatedUntil=endX; worldMaxX=Math.max(worldMaxX,endX);
}

function makeRobot(rx){
  return {
    x:rx,y:VH-TILE*2,w:18,h:24,
    vx:0,vy:0,onGround:false,
    dir:Math.random()<.5?-1:1,speed:.66,hp:3,
    active:false,hitUntil:0, stunnedUntil:0,
    state:'patrol', jumpCoolUntil:0,
    anim:{state:'idle',runner:null}
  };
}
function makeDrone(dx,dy){
  return {
    x:dx,y:dy,w:18,h:14,dir:Math.random()<.5?-1:1,speed:.8,phase:Math.random()*6,
    active:false, anim:{state:'move',runner:null},
    disabled:false, falling:false, vy:0
  };
}
function makeCollector(x,y){
  return { x,y,w:16,h:22, vx:0, vy:0, onGround:false, speed:.6,
           collected:false, facing:1, anim:{state:'idle',runner:null} };
}

/* ================= PHYSICS ================= */
function collide(body){
  body.onGround=false;
  body.y+=body.vy;
  for(const p of platforms){
    if(rects(body,p)){
      if(body.vy>0){ body.y=p.y-body.h; body.vy=0; body.onGround=true; }
      else if(body.vy<0){ body.y=p.y+p.h; body.vy=0; }
    }
  }
  body.x+=body.vx;
  for(const p of platforms){
    if(rects(body,p)){
      body.y-=2; if(!rects(body,p)){ body.onGround=false; break; } body.y+=2;
      if(body.vx>0) body.x=p.x-body.w; else if(body.vx<0) body.x=p.x+p.w;
      body.vx=0;
    }
  }
}

/* ================= HACK / EMP ================= */
let hackUntil=0, hackCDUntil=0, empTextTimer=0;
function getEmpCharges(){
  const up = JSON.parse(sessionStorage.getItem('playerUpgrades') || '{}');
  return up.mobileEMP && (up.mobileEMPCharges|0) > 0 ? (up.mobileEMPCharges|0) : 0;
}
function setEmpCharges(n){
  const up = JSON.parse(sessionStorage.getItem('playerUpgrades') || '{}');
  up.mobileEMP = true; up.mobileEMPCharges = Math.max(0, n|0);
  sessionStorage.setItem('playerUpgrades', JSON.stringify(up));
}
function triggerEMP(perma=false, duration=3000){
  const now=performance.now();
  hackUntil = now + duration;
  empTextTimer = now + 1200;
  for(const r of robots){ r.stunnedUntil = Math.max(r.stunnedUntil, hackUntil); }
  for(const d of drones){
    if(perma){
      if(!d.disabled){ d.disabled=true; d.falling=true; d.vy=0; }
    }else{
      d.disabled=true;
    }
  }
}
function tryMobileEMP(){
  const charges = getEmpCharges();
  if(charges<=0) return;
  setEmpCharges(charges-1);
  triggerEMP(true, 3200);
}
function tryHack(){
  const now=performance.now(); if(now<hackCDUntil) return;
  const near=terminals.find(t=>Math.hypot((t.x+6)-(player.x+player.w/2),(t.y+8)-(player.y+player.h/2))<18 && t.cooldown<=0);
  if(near){
    triggerEMP(false, 3000);
    hackCDUntil=now+5000; near.cooldown=5000; score+=20;
  }
}

/* ================= COINS + MAGNET ================= */
function pickupCoins(){
  for (const c of coins){
    if (c.taken) continue;
    const px = player.x + player.w/2, py = player.y + player.h/2;
    const dx = c.x - px, dy = c.y - py;
    const dist2 = dx*dx + dy*dy;

    const hasMagnet = !!(player.upgrades && player.upgrades.coinMagnet);
    const magnetR = hasMagnet ? 80 : 26;
    if (dist2 <= magnetR*magnetR){
      const d = Math.sqrt(dist2) || 1;
      const pull = hasMagnet ? 1.55 : 0.65;
      c.x -= (dx/d) * pull;
      c.y -= (dy/d) * pull;
    }
    const rr = (c.r || 10) + 8;
    if (dist2 <= rr*rr){
      c.taken = true;
      btc += 1; score += 5;
    }
  }
}

/* ================= CAMERA ================= */
const DEAD_ZONE=8;
function updateCamera(){
  const center=VW*0.40;
  const L=center-DEAD_ZONE, R=center+DEAD_ZONE;
  let target=cameraX;
  if(player.x-cameraX<L) target=player.x-L;
  else if(player.x-cameraX>R) target=player.x-R;
  cameraX += (target-cameraX)*0.45;
  cameraX=Math.max(0,Math.min(cameraX, worldMaxX-VW));
}
function cull(){ const cutoff=cameraX-300;
  for(let i=ads.length-1;i>=0;i--) if(ads[i].x+160<cutoff) ads.splice(i,1);
  for(let i=robots.length-1;i>=0;i--) if(robots[i].x+120<cutoff) robots.splice(i,1);
  for(let i=drones.length-1;i>=0;i--) if(drones[i].x+120<cutoff) drones.splice(i,1);
  for(let i=npcs.length-1;i>=0;i--) if(npcs[i].x+120<cutoff) npcs.splice(i,1);
  for(let i=coins.length-1;i>=0;i--) if(coins[i].x+40<cutoff) coins.splice(i,1);
}
function activateEnemies(){
  const visRight = cameraX + VW + 64;
  for(const r of robots){ if(!r.active && r.x<visRight) r.active=true; }
  for(const d of drones){ if(!d.active && d.x<visRight) d.active=true; }
}
function playerLitByCone(){
  if(currentLevel!==2) return false;
  for(const d of drones){
    const coneW = 60, coneH = 100;
    const px = player.x + player.w/2;
    const withinX = Math.abs(px - d.x) < coneW*0.5;
    const below   = (player.y + player.h) > d.y && (player.y < d.y + coneH);
    if(withinX && below) return true;
  }
  return false;
}

/* ================= UPDATE LOOP ================= */
function update(dt,now){
  if(gameState!=='playing') return;

  for(const t of terminals){ if(t.cooldown>0) t.cooldown=Math.max(0,t.cooldown-dt); }

  const L=!!keys['ArrowLeft'], R=!!keys['ArrowRight'];
  const accel=player.onGround?player.aGround:player.aAir;
  const drag=player.onGround?player.dragG:player.dragA;
  if(L){ player.vx=Math.max(player.vx-accel,-player.speed); player.facing=-1; }
  if(R){ player.vx=Math.min(player.vx+accel, player.speed);  player.facing= 1; }
  if(!L && !R) player.vx*=drag;

  if(player.onGround) coyoteUntil=now+COYOTE;
  const wantsJump = now<=jumpBufferUntil;
  if(wantsJump && (player.onGround || now<=coyoteUntil)){ player.vy=-player.jump; player.onGround=false; jumpBufferUntil=0; coyoteUntil=0; }
  if(!jumpHeld && player.vy<-1.25) player.vy=-1.25;

  player.vy+=.18; if(player.vy>3.7) player.vy=3.7;

  collide(player);
  pickupCoins();

  if(player.hp<=0){ gameState='gameOver'; document.getElementById('resetBtn').style.display='block'; }
  else if(now<player.hitUntil) setAnim(player,'player','hurt',true);
  else { const s=Math.abs(player.vx); setAnim(player,'player', s>1.05?'run':(s>0.2?'walk':'idle')); }
  stepAnim(player,dt);

  const need=cameraX+VW+CHUNK*2; while(generatedUntil<need) genChunk(generatedUntil);
  activateEnemies();

  // drones (EMP + fall)
  for(const d of drones){
    if(!d.active) continue;
    if(d.disabled && hackUntil<now && !d.falling) d.disabled=false;
    if(d.falling){
      d.vy = Math.min(3.2, d.vy + 0.18);
      d.y += d.vy;
      if(d.y >= groundY()-14){ d.y = groundY()-14; d.vy=0; d.falling=false; d.disabled=true; d.speed=0; }
    }else if(!d.disabled){
      d.x+=d.dir*d.speed; d.phase+=.02; d.y+=Math.sin(d.phase)*.2;
      if((d.x%CHUNK)<8||(d.x%CHUNK)>CHUNK-8) d.dir*=-1;
    }
  }

  const lit = playerLitByCone();

  // robots
  for(const r of robots){
    if(!r.active) continue;
    r.vy += .18; if(r.vy>3.2) r.vy=3.2;
    collide(r);

    const stunned = now < r.stunnedUntil;
    if(stunned){ setAnim(r,'robot','idle'); stepAnim(r,dt); continue; }

    const dx = player.x - r.x;
    const dy = player.y - r.y;
    const see = Math.abs(dx) < 92 && Math.abs(dy) < 56;
    const playerAbove = (player.y + player.h) < (r.y - 4);

    if(see){ r.dir = dx > 0 ? 1 : -1; r.vx = r.dir * r.speed * 1.25; setAnim(r,'robot','run'); }
    else    { r.vx = r.dir * r.speed; setAnim(r,'robot','walk'); }

    if(currentLevel===2 && playerAbove && lit && now>r.jumpCoolUntil && r.onGround){
      r.vy = -3.0; r.jumpCoolUntil = now + 900;
    }

    stepAnim(r,dt);

    if(rects(player,r)){
      if(player.vy>0 && player.y+player.h<=r.y+6){ r.hp--; r.hitUntil=now+120; player.vy=-2.6; score+=12; }
      else{
        player.vx+=(player.x<r.x)?-0.8:0.8;
        player.hp=Math.max(0, player.hp-7); player.hitUntil=now+150;
        if(player.hp<=0){ gameState='gameOver'; document.getElementById('resetBtn').style.display='block'; }
      }
    }
  }
  for(let i=robots.length-1;i>=0;i--) if(robots[i].hp<=0) robots.splice(i,1);

  // collectors (L3) — take up to 5 BTC once, then idle
  for(const n of npcs){
    const dir = Math.sign((player.x - n.x)) || 1;
    n.facing = dir;
    if(!n.collected){
      n.vx = dir * n.speed;
      setAnim(n,'female', Math.abs(n.vx)>0.05 ? 'run' : 'idle');
    }else{
      n.vx *= 0.9;
      setAnim(n,'female','idle');
    }
    n.vy += .18; if(n.vy>3.2) n.vy=3.2;
    collide(n);
    stepAnim(n,dt);

    if(rects(player,n) && !n.collected){
      const take = Math.min(5, btc);   // 5 BTC max; if <5, takes remaining
      if(take > 0) btc -= take;
      n.collected = true;
      n.vx = 0;
    }
  }

  // exit door → shop
  if(exitDoor && rects(player, exitDoor)){
    gameState='levelComplete';
    setTimeout(()=>{ 
      saveForShop();
      location.href = `./blackout-protocol/game-shop.html?level=${currentLevel}&btc=${btc}&score=${score}`;
    }, 250);
  }

  updateCamera(); cull();
}

/* ================= DRAW ================= */
function drawCoins(){
  for(const c of coins){
    if(c.taken) continue;
    const x=(c.x-cameraX)|0, y=c.y|0; if(x<-16||x>VW+16) continue;
    if(coinImg && coinImg.complete && coinImg.naturalWidth){
      const s=20; nesCtx.save(); nesCtx.shadowColor='#ffaa00'; nesCtx.shadowBlur=8; nesCtx.drawImage(coinImg, x-s/2, y-s/2, s, s); nesCtx.restore();
    }else{
      nesCtx.fillStyle='#ffd95e'; nesCtx.beginPath(); nesCtx.arc(x, y, 6, 0, Math.PI*2); nesCtx.fill();
      nesCtx.strokeStyle='#ffaa00'; nesCtx.lineWidth=2; nesCtx.stroke();
      nesCtx.fillStyle='#000'; nesCtx.font='8px monospace'; nesCtx.textAlign='center'; nesCtx.fillText('₿', x, y+2);
      nesCtx.textAlign='left';
    }
  }
}
function drawTerminals(){
  for(const t of terminals){ 
    const x=(t.x-cameraX)|0; if(x+t.w<0||x>VW) continue;
    const img = (Math.floor(performance.now()/300)%2) ? terminalFrame1 : terminalFrame2;
    if(img && img.complete && img.naturalWidth){
      nesCtx.save(); if(t.cooldown<=0){nesCtx.shadowColor='#00ff9d';nesCtx.shadowBlur=4;} else {nesCtx.shadowColor='#ff4444';nesCtx.shadowBlur=2;}
      nesCtx.drawImage(img, x-2, t.y-4, t.w+4, t.h+4); nesCtx.restore();
    }else{
      nesCtx.fillStyle = t.cooldown > 0 ? '#6b4d9b' : '#9b6bff'; 
      nesCtx.fillRect(x,t.y,t.w,t.h);
    }
  }
}
function drawTiles(){
  const ok = (im)=>im && im.complete && im.naturalWidth>0;
  const img = ok(ledgeImg) ? ledgeImg : (ok(platformImg) ? platformImg : null);
  const RAIL_FRAC=0.55, DST_BASE_H=20;
  for (const p of platforms){
    const sx = p.x - cameraX; if (sx + p.w < 0 || sx > VW) continue;
    if (!img){
      nesCtx.fillStyle = '#1a2332'; nesCtx.fillRect(sx|0, p.y|0, p.w, TILE);
      nesCtx.fillStyle = '#6fc2ff'; nesCtx.fillRect(sx|0, p.y|0, p.w, 2);
      nesCtx.fillStyle = '#4a5568'; nesCtx.fillRect(sx|0, (p.y+TILE-2)|0, p.w, 2);
      continue;
    }
    const iw = img.naturalWidth, ih = img.naturalHeight;
    const srcBaseY = Math.floor(ih * RAIL_FRAC);
    const srcBaseH = ih - srcBaseY;
    const srcX = 1, srcW = Math.max(1, iw - 2);
    const dy = (p.y - (DST_BASE_H - TILE)) | 0;
    nesCtx.drawImage(img, srcX, srcBaseY, srcW, srcBaseH, sx|0, dy, p.w, DST_BASE_H);
  }
}
function drawRailsOnTop(){
  const img = ledgeImg && ledgeImg.complete && ledgeImg.naturalWidth ? ledgeImg : null;
  if (!img) return;
  const RAIL_FRAC=0.55, DST_BASE_H=20;
  const iw = img.naturalWidth, ih = img.naturalHeight;
  const railSrcH = Math.floor(ih * RAIL_FRAC);
  const baseSrcH = ih - railSrcH;
  const scale    = DST_BASE_H / baseSrcH;
  const railDstH = Math.max(10, Math.round(railSrcH * scale));
  const srcX = 1, srcW = Math.max(1, iw - 2);
  for (const p of platforms){
    if (p.y >= VH - TILE) continue;
    const sx = p.x - cameraX; if (sx + p.w < 0 || sx > VW) continue;
    const y  = (p.y - railDstH) | 0;
    nesCtx.drawImage(img, srcX, 0, srcW, railSrcH, sx|0, y, p.w, railDstH);
  }
}
function drawDronesAndCones(){
  for(const d of drones){
    const x=(d.x-cameraX)|0, y=d.y|0; if(x+32<0||x>VW) continue;
    if(currentLevel===2){
      const coneW=60, coneH=100;
      nesCtx.save();
      nesCtx.globalAlpha = d.disabled ? 0.15 : 0.22;
      nesCtx.fillStyle   = '#9ad1ff';
      nesCtx.beginPath();
      nesCtx.moveTo(x, y+8);
      nesCtx.lineTo(x - coneW/2, y + coneH);
      nesCtx.lineTo(x + coneW/2, y + coneH);
      nesCtx.closePath();
      nesCtx.fill();
      nesCtx.restore();
    }
    if(!d.anim?.runner) setAnim(d,'drone','move');
    stepAnim(d,16);
    d.anim.runner.draw(x-7,y-9,false, d.disabled?0.55:1);
  }
}
function drawEntities(now){
  for(const r of robots){
    const x=(r.x-cameraX)|0, y=r.y|0; if(x+48<0||x>VW) continue;
    const alpha = now<r.stunnedUntil ? 0.65 : (now<r.hitUntil?0.75:1);
    r.anim.runner?.draw(x-14,y-24,(player.x<r.x), alpha);
  }
  drawDronesAndCones();

  for(const n of npcs){
    const x=(n.x-cameraX)|0, y=n.y|0; if(x+24<0||x>VW) continue;
    n.anim.runner?.draw(x-15, y-26, n.facing<0, 1);
  }

  const px=(player.x-cameraX)|0, py=player.y|0;
  player.anim.runner?.draw(px-15,py-20, player.facing===-1, performance.now()<player.hitUntil?0.8:1);
}
function drawExitDoor(){
  if(!exitDoor) return;
  const x=(exitDoor.x-cameraX)|0, y=exitDoor.y|0;
  if(doorImg && doorImg.complete && doorImg.naturalWidth){
    nesCtx.save(); nesCtx.shadowColor = '#ff1493'; nesCtx.shadowBlur = 6;
    nesCtx.drawImage(doorImg, x, y, exitDoor.w, exitDoor.h);
    nesCtx.restore();
  }else{
    nesCtx.fillStyle='#2a3040'; nesCtx.fillRect(x,y,exitDoor.w,exitDoor.h); 
  }
}
function drawControlsHint() {
  const ctx = nesCtx;
  const title = 'Blackout Protocol';
  ctx.font='9px monospace'; ctx.textAlign='left';
  const titleW = ctx.measureText(title).width;
  ctx.fillStyle='#cfd6df'; ctx.fillText(title,6,4);

  const pad = 6;
  const avail = VW - (titleW + pad*2 + 2);
  const candidates = [
    {text:'← → Move | Space | Enter(Hack) | E(EMP) | ESC', size:8},
    {text:'← → Move | Space | Enter | E | ESC',           size:8},
    {text:'←→|␣|⏎|E|ESC',                                 size:7},
  ];
  let pick = candidates[0];
  for (const c of candidates){
    ctx.font = `${c.size}px monospace`;
    if (ctx.measureText(c.text).width <= avail){ pick=c; break; }
  }
  ctx.textAlign='right';
  ctx.fillStyle='#9aa3b2';
  ctx.font = `${pick.size}px monospace`;
  ctx.fillText(pick.text, VW-4, 4);
  ctx.textAlign='left';
  ctx.font='9px monospace';
}
function drawUI(now){
  nesCtx.fillStyle='rgba(0,0,0,.78)'; nesCtx.fillRect(0,0,VW,20);
  drawControlsHint();

  const charges = getEmpCharges();
  nesCtx.fillStyle='#fff'; nesCtx.fillText(`HP:${Math.max(0,player.hp)}  L:${currentLevel}  SC:${score}  BTC:${btc}`,6,24);
  if(charges>0){ nesCtx.fillStyle='#7dff9a'; nesCtx.fillText(`EMP Charges:${charges}`, 6, 36); }

  if(gameState==='paused'){ nesCtx.fillStyle='rgba(0,0,0,.6)'; nesCtx.fillRect(0,0,VW,VH); nesCtx.fillStyle='#fff'; nesCtx.fillText('PAUSED (ESC)',VW/2-30,VH/2); }
  if(gameState==='gameOver'){ nesCtx.fillStyle='rgba(0,0,0,.7)'; nesCtx.fillRect(0,0,VW,VH); nesCtx.fillStyle='#fff'; nesCtx.fillText('GAME OVER',VW/2-34,VH/2-8); nesCtx.fillText(`Score ${score}  BTC ${btc}`,VW/2-40,VH/2+4); nesCtx.fillText('Press R to restart L1',VW/2-52,VH/2+16); }
  if(gameState==='levelComplete'){ nesCtx.fillStyle='rgba(0,0,0,.7)'; nesCtx.fillRect(0,0,VW,VH); nesCtx.fillStyle='#7dff9a'; nesCtx.fillText('LEVEL COMPLETE → SHOP',VW/2-60,VH/2-8); }
}

/* ======== HOLOGRAM POSTERS (overlay canvas) ======== */
function drawOverlay(now){
  octx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  if(!(ADS_BY_LEVEL[currentLevel]||[]).length) return;
  for(const a of ads){
    const img = AdImages[a.kind]; if(!img) continue;
    const sx=Math.round(RENDER.ox+(a.x-cameraX)*RENDER.scale);
    const sy=Math.round(RENDER.oy+a.y*RENDER.scale);
    if(sx<-200 || sx>overlayCanvas.width+200) continue;

    a.phase = (a.phase||0) + 0.03;
    const flick = 0.65 + 0.35*Math.sin(a.phase*3);
    const bob   = Math.sin(a.phase)*2*RENDER.scale;
    const tilt  = (Math.sin(a.phase*0.6))*0.03;

    const targetW = Math.round(56*RENDER.scale);
    const ratio = img.height ? (img.width/img.height) : 1;
    const w = targetW, h = Math.max(11, Math.round((targetW/ratio)));
    const x = sx - Math.round(w/2), y = sy - Math.round(h/2) + bob;

    octx.globalAlpha = 0.85;
    octx.fillStyle = 'rgba(10,14,20,0.5)';
    octx.fillRect(x-8,y-8,w+16,h+16);
    octx.globalAlpha = 1;
    octx.strokeStyle = `rgba(111,194,255,0.5)`;
    octx.lineWidth = 2;
    octx.strokeRect(x-8,y-8,w+16,h+16);

    octx.save();
    octx.translate(x+w/2, y+h/2);
    octx.rotate(tilt);
    octx.globalAlpha = 0.72 + 0.12*Math.sin(a.phase*2);
    octx.drawImage(img, -w/2, -h/2, w, h);
    octx.globalAlpha = 0.18 * flick;
    octx.shadowColor = '#6fc2ff';
    octx.shadowBlur  = 22;
    octx.drawImage(img, -w/2, -h/2, w, h);
    octx.restore();

    octx.globalAlpha = 0.12*flick;
    octx.fillStyle = '#6fc2ff';
    octx.fillRect(x-8, y + (h*0.2|0), w+16, 1);
    octx.globalAlpha = 1;
  }
}

/* ================= BLIT ================= */
function blit(){
  gctx.clearRect(0,0,gcanvas.width,gcanvas.height);
  const s=Math.min(gcanvas.width/VW, gcanvas.height/VH);
  const sw=(VW*s)|0, sh=(VH*s)|0, ox=((gcanvas.width-sw)/2)|0, oy=((gcanvas.height-sh)/2)|0;
  gctx.drawImage(nes,0,0,VW,VH,ox,oy,sw,sh); RENDER={scale:s,ox,oy};
}

/* ================= RESET / BOOT ================= */
function placeExitDoor(){ exitDoor={x:LEVEL_LEN-40, y:groundY()-DOOR_H, w:DOOR_W, h:DOOR_H}; }

function hardResetToL1(){
  setLevel(1);
  clearRun();
  boot(true);
}

function startLevel(lv){
  currentLevel = Math.max(1, lv|0);
  setLevel(currentLevel);
  if (player) player.hp = 100; // health reset per level start
  setN('playerBTC', btc);
  setN('playerScore', score);
}

function saveForShop(){
  setN('playerBTC', btc);
  setN('playerScore', score);
  setN('gameLevel', currentLevel);
}

function resetFromSaved(){
  // player & world
  player = makePlayer();
  player.hp = 100; // always start level with full health

  platforms=[]; robots=[]; drones=[]; npcs=[]; terminals=[]; ads=[]; coins=[];
  generatedUntil=0; exitDoor=null;

  // restore run stats
  score=getN('playerScore', 0);
  btc=getN('playerBTC', 0);
  currentLevel=getLevel();

  for(let x=0;x<CHUNK*4;x+=CHUNK) genChunk(x);
  if(currentLevel===2 && drones.length<2){
    drones.push(makeDrone(420,70), makeDrone(820,80), makeDrone(1200,60));
  }
  placeExitDoor();
  document.getElementById('resetBtn').style.display='none';
  gameState='playing';
}

/* ================= BOOT & LOOP ================= */
async function boot(forceL1=false){
  try{
    if(forceL1) setLevel(1);
    await loadBackgroundsForLevel(getLevel());
    SPR = await loadSprites(SPRITE_DEF);
    await Promise.all([loadTiles(), loadAdImages(getLevel())]);
    resetFromSaved();
    READY=true;
  }catch(err){ console.error(err); LOAD_MSG='Load failed (check console)'; }
}

function loop(now){
  const dt = loop.t ? now - loop.t : 16; loop.t = now;
  if (!READY){
    nesCtx.fillStyle='#000'; nesCtx.fillRect(0,0,VW,VH);
    nesCtx.fillStyle='#cfd6df'; nesCtx.fillText(LOAD_MSG, VW/2 - 20, VH/2);
    blit(); requestAnimationFrame(loop); return;
  }
  if (gameState==='playing') update(dt, now);
  nesCtx.fillStyle='#000'; nesCtx.fillRect(0,0,VW,VH);
  drawBackgrounds();
  drawTiles(); drawTerminals(); drawCoins(); drawExitDoor(); drawEntities(now); drawRailsOnTop(); drawUI(now);
  blit(); drawOverlay(now);
  requestAnimationFrame(loop);
}

/* ================= STARTUP ================= */
window.addEventListener('load', ()=>{
  gcanvas = document.getElementById('gameCanvas');
  gctx    = gcanvas.getContext('2d');
  overlayCanvas = document.getElementById('overlayCanvas');
  octx = overlayCanvas.getContext('2d');

  fit();

  // Query params allow resume=1&level=#
  const qs = new URLSearchParams(location.search);
  const resume = qs.get('resume') === '1';
  if (resume) {
    const lvlFromUrl = parseInt(qs.get('level')||'');
    if (Number.isFinite(lvlFromUrl)) { currentLevel = lvlFromUrl; setLevel(lvlFromUrl); }
    score = getN('playerScore', 0);
    btc   = getN('playerBTC', 0);
  } else {
    currentLevel = getLevel();
    score = getN('playerScore', 0);
    btc   = getN('playerBTC', 0);
  }

  document.getElementById('resetBtn').addEventListener('click', hardResetToL1);
  boot().then(()=> requestAnimationFrame(loop));
});
</script>
</body>
</html>

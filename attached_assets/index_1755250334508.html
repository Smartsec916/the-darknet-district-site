<!DOCTYPE html>
<html lang="en">
<head>
  <base href="/blackout-protocol/">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Blackout Protocol — Level Runtime</title>
  <style>
    :root { --frame-w: 960px; }
    html,body{margin:0;background:#000;color:#cfd6df;font-family:monospace;overflow:hidden;}
    #gameContainer{position:relative;width:100%;max-width:var(--frame-w);margin:0 auto;aspect-ratio:4/3;background:#000;border:2px solid #5c5c5c;}
    canvas{position:absolute;inset:0;display:block;image-rendering:pixelated;image-rendering:crisp-edges;}
    #overlayCanvas{pointer-events:none;}
    #resetBtn{position:absolute;left:50%;top:50%;transform:translate(-50%,-8px);padding:10px 16px;background:#0f1016;border:2px solid #626a78;border-radius:6px;color:#cfd6df;letter-spacing:.6px;display:none;cursor:pointer;z-index:5}
    #resetBtn:hover{filter:brightness(1.15)}
    #endBtn{position:absolute;left:50%;top:58%;transform:translate(-50%,0);padding:10px 16px;background:#101625;border:2px solid #6fc2ff;border-radius:10px;color:#e8f3ff;letter-spacing:.6px;display:none;cursor:pointer;z-index:6}
    #endBtn:hover{filter:brightness(1.1)}
  </style>

  <!-- SESSION BOOTSTRAP -->
  <script>
  (function bootstrapSession(){
    try {
      if (!sessionStorage.getItem('bp_session_started')) {
        try { sessionStorage.clear(); } catch(e){}
        sessionStorage.setItem('bp_session_started', '1');
      }
      var _qs = new URLSearchParams(location.search);
      if (_qs.has('fresh')) {
        try { sessionStorage.clear(); } catch(e){}
        sessionStorage.setItem('bp_session_started','1');
      }
    } catch(e){}
  })();
  </script>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <canvas id="overlayCanvas"></canvas>
  <button id="resetBtn" type="button">Reset (R)</button>
  <button id="endBtn" type="button">Start Fresh</button>
</div>

<script type="module">
/* ================= CONFIG ================= */
const SHOP_URL = './game-shop.html';
const LEVEL_LEN = 1600;
const DOOR_W = 24, DOOR_H = 32;
const HYPER_RELOAD_TAG = 'rev=' + Date.now();

/* ================= STORAGE HELPERS ================= */
function SSgetN(k,d){ const n=parseInt(sessionStorage.getItem(k)||''); return Number.isFinite(n)?n:d; }
function SSsetN(k,v){ sessionStorage.setItem(k,String(v)); }
function SSgetO(k){ try{ return JSON.parse(sessionStorage.getItem(k)||'{}'); }catch{ return {}; } }
function SSsetO(k,v){ sessionStorage.setItem(k, JSON.stringify(v)); }
function getLevel(){ return Math.max(1, SSgetN('gameLevel', 1)); }
function setLevel(n){ SSsetN('gameLevel', Math.max(1,n)); }

/* Leaderboard (localStorage) */
const LB_KEY='leaderboard';
function getLeaderboard(){ try{ return JSON.parse(localStorage.getItem(LB_KEY)||'[]'); }catch{ return []; } }
function setLeaderboard(arr){ localStorage.setItem(LB_KEY, JSON.stringify(arr.slice(0,10))); }

/* ================= CORE / DISPLAY ================= */
let READY=false, LOAD_MSG='Loading…';
addEventListener('error', e => console.error('Runtime error:', e.message));

const VW=256, VH=240, TILE=16;

const gameCanvas=document.getElementById('gameCanvas');
const overlayCanvas=document.getElementById('overlayCanvas');
const gctx=gameCanvas.getContext('2d'); gctx.imageSmoothingEnabled=false;
const octx=overlayCanvas.getContext('2d');

const nes=document.createElement('canvas'); nes.width=VW; nes.height=VH;
const ctx=nes.getContext('2d',{alpha:false});
ctx.imageSmoothingEnabled=false;
ctx.font='9px monospace';
ctx.textBaseline='top';

let RENDER={scale:1,ox:0,oy:0};
function fit(){
  const r=document.getElementById('gameContainer').getBoundingClientRect();
  gameCanvas.width=r.width; gameCanvas.height=r.height;
  overlayCanvas.width=r.width; overlayCanvas.height=r.height;
}
addEventListener('resize',fit); fit();

addEventListener('keydown',e=>{
  if(['Space','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.code)) e.preventDefault();
},{passive:false});

/* ================= ASSETS ================= */
const IMG = (path) => new Promise(resolve=>{
  if(!path){ resolve(null); return; }
  const i=new Image();
  i.onload=()=>{ console.log('✓ Asset loaded:', path); resolve(i); };
  i.onerror=()=>{ console.error('✗ Failed to load asset:', path); resolve(null); };
  i.src=path;
});

/* Sprite + static art definitions (backgrounds set per-level at boot) */
const SPRITE_DEF={
  player:{fw:48,fh:48, states:{
    idle:'assets/player_idle_48.png', walk:'assets/player_walk_48.png', run:'assets/player_run_48.png',
    jump:'assets/player_jump_48.png', fall:'assets/player_fall_48.png', hurt:'assets/player_hurt_48.png', dead:'assets/player_dead_48.png'
  }, fps:{idle:6, walk:10, run:12, jump:10, fall:10, hurt:6, dead:8}},
  robot:{fw:48,fh:48, states:{
    idle:'assets/robot_idle_48.png', walk:'assets/robot_walk_48.png', run:'assets/robot_run_48.png',
    attack:'assets/robot_attack_48.png', hurt:'assets/robot_hurt_48.png', dead:'assets/robot_dead_48.png'
  }, fps:{idle:6, walk:9, run:10, attack:12, hurt:6, dead:8}},
  drone:{fw:32,fh:32, states:{
    idle:'assets/drone_idle_32.png', hover:'assets/drone_hover_32.png', move:'assets/drone_move_32.png',
    attack:'assets/drone_attack_32.png', hurt:'assets/drone_hurt_32.png', dead:'assets/drone_dead_32.png'
  }, fps:{idle:3, hover:10, move:10, attack:12, hurt:6, dead:8}},
  female:{fw:48,fh:48, states:{
    idle:'assets/female_idle.png', run:'assets/female_run.png'
  }, fps:{idle:6, run:10}},
  bg_far:null, bg_near:null, coin:null, door:null, ledge:null, platform:null, terminal:''
};

/* ===== Level-specific Ads ===== */
function adConfigForLevel(lvl){
  if(lvl===2){
    return {
      kinds:['blackrock','downthere','oxygen','skinshift','zen'],
      images:{
        blackrock:`assets/Blackrock.png?${HYPER_RELOAD_TAG}`,
        downthere:`assets/Downthere.png?${HYPER_RELOAD_TAG}`,
        oxygen:`assets/Oxygen.png?${HYPER_RELOAD_TAG}`,
        skinshift:`assets/Skinshift.png?${HYPER_RELOAD_TAG}`,
        zen:`assets/Zen.png?${HYPER_RELOAD_TAG}`,
      }
    };
  }
  if(lvl===3){
    return {
      kinds:['bug','pill','plug','touchless','pinknoise'],
      images:{
        bug:`assets/Bug.png?${HYPER_RELOAD_TAG}`,
        pill:`assets/Pill.png?${HYPER_RELOAD_TAG}`,
        plug:`assets/Plug.png?${HYPER_RELOAD_TAG}`,
        touchless:`assets/Touchless.png?${HYPER_RELOAD_TAG}`,
        pinknoise:`assets/Pinknoise.png?${HYPER_RELOAD_TAG}`,
      }
    };
  }
  // Level 1 (original set)
  return {
    kinds:['fourk','meat','holo','rent','drink'],
    images:{
      fourk:`assets/4K.png?${HYPER_RELOAD_TAG}`,
      meat:`assets/Meat.png?${HYPER_RELOAD_TAG}`,
      holo:`assets/HoloCompanion.png?${HYPER_RELOAD_TAG}`,
      rent:`assets/Rent.png?${HYPER_RELOAD_TAG}`,
      drinkA:`assets/Drink_Oil_01.png?${HYPER_RELOAD_TAG}`,
      drinkB:`assets/Drink_Oil_02.png?${HYPER_RELOAD_TAG}`,
    }
  };
}
let CurrentAds={kinds:[], images:{}, imgObjs:{}};
let adDeck=[];
function refillDeck(){ adDeck=[...CurrentAds.kinds].sort(()=>Math.random()-0.5); }
function nextAdKind(){ if(!adDeck.length) refillDeck(); return adDeck.shift(); }
async function loadAdImagesForLevel(lvl){
  CurrentAds = adConfigForLevel(lvl);
  CurrentAds.imgObjs = {};
  const keys = Object.keys(CurrentAds.images||{});
  for(const k of keys){
    CurrentAds.imgObjs[k] = await IMG(CurrentAds.images[k]);
  }
  refillDeck();
}

/* Animator helper */
function makeAnimator(sheet, fw, fh, fps){
  const frames = sheet ? Math.max(1, Math.floor(sheet.width / fw)) : 1;
  let frame=0, time=0, spf=1000/(fps||8);
  return {
    reset(){ frame=0; time=0; },
    step(dt, clamp=false){ time+=dt; while(time>spf){ time-=spf; frame = clamp ? Math.min(frame+1, frames-1) : (frame+1)%frames; } },
    draw(x,y,flip=false,alpha=1){
      if(!sheet){ // visible fallback if sprite missing
        ctx.save();
        ctx.globalAlpha=alpha;
        ctx.fillStyle='#8a99ff';
        ctx.fillRect(x+6,y+6,36,36);
        ctx.strokeStyle='#2a3a8f';
        ctx.strokeRect(x+6,y+6,36,36);
        ctx.restore();
        return;
      }
      const sx=frame*fw, sy=0;
      ctx.save(); ctx.globalAlpha=alpha;
      if(flip){ ctx.translate(x+fw,y); ctx.scale(-1,1); ctx.drawImage(sheet,sx,sy,fw,fh,0,0,fw,fh); }
      else    { ctx.drawImage(sheet,sx,sy,fw,fh,x,y,fw,fh); }
      ctx.restore();
    },
    frames
  };
}

/* ================= PARALLAX ================= */
const BG={far:null, near:null};
const PARALLAX={far:0.18, near:0.55};
const NEAR_FADE_PX=120;

function bgURLsForLevel(lvl){
  if(lvl===2) return {far:`assets/02_bg_far.png?${HYPER_RELOAD_TAG}`, near:`assets/02_bg_near.png?${HYPER_RELOAD_TAG}`};
  if(lvl===3) return {far:`assets/03_bg_far.png?${HYPER_RELOAD_TAG}`, near:`assets/03_bg_near.png?${HYPER_RELOAD_TAG}`};
  if(lvl===4) return {far:`assets/03_bg_far.png?${HYPER_RELOAD_TAG}`, near:`assets/03_bg_near.png?${HYPER_RELOAD_TAG}`}; // reuse
  return {far:`assets/01_bg_far.png?${HYPER_RELOAD_TAG}`, near:`assets/01_bg_near.png?${HYPER_RELOAD_TAG}`};
}
function setBackgroundsForLevel(lvl){
  const urls = bgURLsForLevel(lvl);
  SPRITE_DEF.bg_far  = urls.far;
  SPRITE_DEF.bg_near = urls.near;
  SPRITE_DEF.coin    = `assets/btc_glow.png?${HYPER_RELOAD_TAG}`;
  SPRITE_DEF.door    = `assets/shop_door_neon.png?${HYPER_RELOAD_TAG}`;
  SPRITE_DEF.ledge   = `assets/ledge_tile.png?${HYPER_RELOAD_TAG}`;
  SPRITE_DEF.platform= `assets/platform_industrial.png?${HYPER_RELOAD_TAG}`;
}
async function loadBackgrounds(){
  BG.far  = await IMG(SPRITE_DEF.bg_far);
  BG.near = await IMG(SPRITE_DEF.bg_near);
}
function tileParallax(img, speed){
  if(!img) return;
  const scale = VH / img.height;
  const tileW = Math.max(1, Math.round(img.width * scale));
  const cam = cameraX||0;
  let x = -Math.floor((cam*speed) % tileW);
  if (x>0) x -= tileW;
  for(let i=0;i<4;i++){
    const drawX = x + i*tileW;
    const flip = (i%2)===1;
    ctx.save();
    if(flip){
      ctx.translate(drawX + tileW, 0);
      ctx.scale(-1,1);
      ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, tileW, VH);
    }else{
      ctx.drawImage(img, 0, 0, img.width, img.height, drawX, 0, tileW, VH);
    }
    ctx.restore();
  }
}
function drawBackgrounds(){
  if(!BG.far && !BG.near){ drawSky(); return; }
  if(BG.far)  tileParallax(BG.far,  PARALLAX.far);
  if(BG.near){
    ctx.save();
    tileParallax(BG.near, PARALLAX.near);
    const fadeH=Math.min(NEAR_FADE_PX,VH);
    const g=ctx.createLinearGradient(0,0,0,fadeH);
    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,1)');
    ctx.globalCompositeOperation='destination-in';
    ctx.fillStyle=g; ctx.fillRect(0,0,VW,VH);
    ctx.restore();
  }
}
function drawSky(){
  for(let y=0;y<VH;y++){ const t=y/VH; ctx.fillStyle=`rgb(${12+18*t|0},${16+30*t|0},${30+58*t|0})`; ctx.fillRect(0,y,VH,1); }
}

/* ================= SPRITES ================= */
async function loadSprites(def){
  const out={};
  for(const who of ['player','robot','drone','female']){
    const fw=def[who].fw, fh=def[who].fh;
    const pack={fw,fh,anim:{}};
    for(const [state,src] of Object.entries(def[who].states)){
      const img=await IMG(src);
      pack.anim[state]={img, make:()=>makeAnimator(img,fw,fh, def[who].fps[state]||8)};
    }
    out[who]=pack;
  }
  return out;
}

/* ================= STATE / INPUT / CAMERA ================= */
let gameState='loading', score=0, btc=0, level=1, justLeveled=0, endMode=false;
let cameraX=0, worldMaxX=0;
const CHUNK=320;

const DEAD_ZONE=8;
function updateCamera(){
  const center=VW*0.40;
  const L=center-DEAD_ZONE, R=center+DEAD_ZONE;
  let target=cameraX;
  if(player.x-cameraX<L) target=player.x-L;
  else if(player.x-cameraX>R) target=player.x-R;
  cameraX += (target-cameraX)*0.45;
  cameraX=Math.max(0,Math.min(cameraX, worldMaxX-VW));
}

const keys={}, JUMP_BUFFER=140, COYOTE=140;
let jumpBufferUntil=0, coyoteUntil=0, jumpHeld=false;
addEventListener('keydown',e=>{
  keys[e.code]=true;
  if(endMode && e.code==='Enter'){ startOverFresh(); return; }
  if(['Escape'].includes(e.code)) gameState=(gameState==='playing')?'paused':(gameState==='paused'?'playing':gameState);
  if(e.code==='Space'){ jumpBufferUntil=performance.now()+JUMP_BUFFER; jumpHeld=true; }
  if(e.code==='KeyR' && (gameState==='gameOver'||gameState==='levelComplete')) reset();
  if(e.code==='Enter' && gameState==='playing') tryHack();
  if(e.code==='KeyE' && gameState==='playing') triggerEMP();
});
addEventListener('keyup',e=>{ keys[e.code]=false; if(e.code==='Space') jumpHeld=false; });

/* ================= ENTITIES ================= */
let SPR=null;
let player, robots=[], drones=[], females=[], platforms=[], terminals=[], ads=[], coins=[];
let exitDoor=null;
const resetBtn=document.getElementById('resetBtn'); resetBtn.onclick=()=>reset();
const endBtn=document.getElementById('endBtn'); endBtn.onclick=()=>startOverFresh();

function makePlayer(){
  const savedHealth   = SSgetN('playerHealth', 100);
  const savedUpgrades = SSgetO('playerUpgrades');
  const baseSpeed = 1.52;
  const baseJump  = 5.6;
  const speed = savedUpgrades.speedBoost ? baseSpeed * 1.3 : baseSpeed;
  const jump  = savedUpgrades.jumpBoost  ? baseJump  * 1.2 : baseJump;
  return { x:32, y:VH-80, w:18, h:28, vx:0, vy:0, onGround:false, facing:1,
           speed, aGround:.19, aAir:.12, dragG:.82, dragA:.986, jump,
           hp:savedHealth, dist:0, hitUntil:0, anim:{state:'idle',runner:null},
           upgrades: savedUpgrades };
}
function setAnim(actor, who, state, clamp=false){
  if(actor.anim.state===state) return;
  actor.anim.state=state;
  const spec=SPR[who]?.anim?.[state];
  actor.anim.runner = spec ? spec.make() : null;
  if(actor.anim.runner) actor.anim.runner.reset();
  actor.anim.clamp=clamp;
}
function stepAnim(a,dt){ if(a.anim.runner) a.anim.runner.step(dt, a.anim.clamp); }
function drawAnim(a,who,x,y,flip=false,alpha=1){ const run=a.anim.runner; if(run) run.draw(x,y,flip,alpha); }

/* ================= WORLD GEN ================= */
const groundY = () => VH-TILE;
let generatedUntil=0;

function pushGroundRow(startX,endX){
  for(let x=startX; x<endX; x+=TILE) platforms.push({x,y:groundY(),w:TILE,h:TILE});
}

function genChunk(startX){
  const endX=startX+CHUNK;
  const firstScreen = startX < VW;
  const lvl = getLevel();

  // ground tiles
  pushGroundRow(startX,endX);

  // Level 3: open promenade — no ledges/robots/drones/terminals; place coins + ads
  if(lvl===3){
    if(!firstScreen){
      for(let i=0;i<2;i++){
        const cx = startX + 30 + Math.random()*(CHUNK-60);
        coins.push({x:cx|0, y:(groundY()-24)|0, r:10, taken:false});
      }
      const ax=startX+60+Math.random()*(CHUNK-120), ay=VH-(120+((Math.random()*50)|0));
      ads.push({x:ax|0,y:ay|0,kind:nextAdKind(),phase:Math.random()*6});
    }
    generatedUntil=endX; worldMaxX=Math.max(worldMaxX,endX);
    return;
  }

  // Ledges (L1 ledges pushed right)
  const ledgesStartOffset = (lvl===1) ? 760 : 0;
  const allowLedges = (!firstScreen) && (startX >= ledgesStartOffset);

  if(allowLedges){
    const LOW_LEDGE_OFFSET  = TILE*3;
    const HIGH_LEDGE_OFFSET = TILE*5;

    const baseX = startX + 50 + Math.random()*(CHUNK-140);
    const lowX  = Math.max(startX+24, Math.min(endX-110, (baseX/TILE|0)*TILE));
    const highX = Math.min(endX-60, lowX + TILE*(5 + ((Math.random()*2)|0)));

    const lowW  = TILE*(5 + ((Math.random()*2)|0));
    const highW = TILE*(4 + ((Math.random()*2)|0));

    const lowY  = groundY() - LOW_LEDGE_OFFSET;
    const highY = groundY() - HIGH_LEDGE_OFFSET;

    platforms.push({x:lowX,  y:lowY,  w:lowW,  h:TILE});
    platforms.push({x:highX, y:highY, w:highW, h:TILE});

    // coins above ledges
    const above = [
      {x: lowX + 8 + Math.random()*(Math.max(16, lowW-16)),  y: lowY-20},
      {x: highX + 8 + Math.random()*(Math.max(16, highW-16)), y: highY-20},
      {x: (lowX+highX)/2, y: Math.min(lowY, highY)-26}
    ];
    for(const p of above){ coins.push({x:p.x|0, y:Math.max(40,Math.min(VH-24,p.y))|0, r:10, taken:false}); }

    // terminals (decorative/hackable)
    if(Math.random()<.5){
      const tx=startX+40+Math.random()*(CHUNK-80); let ty=VH-TILE*2;
      for(const p of platforms){ if(tx>=p.x-4 && tx<=p.x+p.w+4) ty=Math.min(ty,p.y-TILE); }
      terminals.push({x:tx|0,y:ty|0,w:12,h:16,cooldown:0});
    }

    // ads
    const ax=startX+60+Math.random()*(CHUNK-120), ay=VH-(120+((Math.random()*50)|0));
    ads.push({x:ax|0,y:ay|0,kind:nextAdKind(),phase:Math.random()*6});
  }

  // robots (L1+). Activation on L1 gated by x≥900:contentReference[oaicite:1]{index=1}.
  if(lvl>=1){
    const rc=1+((Math.random()*2)|0);
    for(let i=0;i<rc;i++){
      const rx=startX+64+Math.random()*(CHUNK-128);
      robots.push({x:rx|0,y:VH-TILE*2,w:18,h:24,dir:Math.random()<.5?-1:1,speed:.66,hp:3,
        active:false,hitUntil:0,state:'patrol', alert:false,patrolL:rx-40, patrolR:rx+40,searchUntil:0, lookTimer:0,
        anim:{state:'idle',runner:null}});
    }
  }
  // drones only on L2+ (never on L1)
  if(lvl>=2){
    if(Math.random()<.6){
      const dx=startX+80+Math.random()*(CHUNK-160), dy=60+Math.random()*80;
      drones.push({x:dx|0,y:dy|0,w:18,h:14,dir:Math.random()<.5?-1:1,speed:.8,phase:Math.random()*6,active:false,disabled:false,
        anim:{state:'move',runner:null}});
    }
  }

  generatedUntil=endX; worldMaxX=Math.max(worldMaxX,endX);
}

/* ================= PHYSICS ================= */
function rects(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
function collide(body){
  body.onGround=false;

  // vertical
  body.y+=body.vy;
  for(const p of platforms){
    if(rects(body,p)){
      if(body.vy>0){ body.y=p.y-body.h; body.vy=0; body.onGround=true; coyoteUntil=0; }
      else if(body.vy<0){ body.y=p.y+p.h; body.vy=0; }
    }
  }

  // horizontal + tiny step-up
  body.x+=body.vx;
  for(const p of platforms){
    if(rects(body,p)){
      if(body.vx>0){
        body.y-=2; if(!rects(body,p)){ body.onGround=false; break; } body.y+=2;
      }else if(body.vx<0){
        body.y-=2; if(!rects(body,p)){ body.onGround=false; break; } body.y+=2;
      }
      if(body.vx>0) body.x=p.x-body.w; else if(body.vx<0) body.x=p.x+p.w;
      body.vx=0;
    }
  }
}

/* ================= HACK / EMP ================= */
let hackUntil=0, hackCDUntil=0; 
const getHackDuration = () => player?.upgrades?.advancedHack ? 5000 : 3000;
function tryHack(){
  const now=performance.now(); if(now<hackCDUntil) return;
  const near=terminals.find(t=>Math.hypot((t.x+6)-(player.x+player.w/2),(t.y+8)-(player.y+player.h/2))<18 && t.cooldown<=0);
  if(near){ const d=getHackDuration(); hackUntil=now+d; hackCDUntil=now+5000; near.cooldown=5000; score+=20; }
}
function triggerEMP(){
  const charges = (player.upgrades?.mobileEMPCharges|0);
  if(!(player.upgrades?.mobileEMP) || charges<=0) return;
  player.upgrades.mobileEMPCharges = charges - 1;
  SSsetO('playerUpgrades', player.upgrades);
  const left = cameraX - 40, right = cameraX + VW + 40;
  robots = robots.filter(r => (r.x < left) || (r.x > right));
  for(const d of drones){
    if(d.x>=left && d.x<=right){ d.disabled = true; d.dir = 0; d.speed = 0; d.y = groundY() - 28; }
  }
}

/* ================= COINS (magnet) ================= */
function pickupCoins(){
  for (const c of coins){
    if (c.taken) continue;
    const px = player.x + player.w/2, py = player.y + player.h/2;
    const dx = c.x - px, dy = c.y - py;
    const dist2 = dx*dx + dy*dy;

    const hasUpgrade = !!(player.upgrades && player.upgrades.coinMagnet === true);
    const magnetR = hasUpgrade ? 56 : 24;
    if (dist2 <= magnetR*magnetR){
      const d = Math.sqrt(dist2) || 1;
      const pull = hasUpgrade ? 1.3 : 0.65;
      c.x -= (dx/d) * pull;
      c.y -= (dy/d) * pull;
    }
    const rr = (c.r || 10) + 8;
    if (dist2 <= rr*rr){
      c.taken = true;
      btc += 1; score += 5;
    }
  }
}

/* ================= DAMAGE / DEATH ================= */
function applyDamage(dmg){
  if (getLevel() === 1) dmg = Math.min(dmg, 20); // friendlier L1
  player.hp = Math.max(0, player.hp - Math.max(0, dmg|0));
  if (player.hp <= 0){ handleDeath(); return; }
  SSsetN('playerHealth', player.hp);
}
function handleDeath(){
  try { sessionStorage.clear(); } catch {}
  sessionStorage.setItem('bp_session_started','1');
  SSsetN('gameLevel', 1);
  SSsetN('playerBTC', 0);
  SSsetN('playerScore', 0);
  SSsetO('playerUpgrades', {});
  SSsetN('playerHealth', 100);
  location.href = 'index.html';
}

/* ================= LEVEL START / SAVE FOR SHOP ================= */
function startLevel(nextLevel){
  setLevel(Math.max(1, nextLevel|0));
  const lvl = getLevel();
  SSsetN('playerHealth', 100);
  SSsetN('playerBTC',   SSgetN('playerBTC', 0));
  SSsetN('playerScore', SSgetN('playerScore', 0));
  SSsetO('playerUpgrades', SSgetO('playerUpgrades'));
}
function saveForShop(){
  SSsetN('playerBTC',   btc|0);
  SSsetN('playerScore', score|0);
  SSsetN('gameLevel',   level|0);
  SSsetO('playerUpgrades', player?.upgrades||SSgetO('playerUpgrades'));
}

/* ================= UPDATE ================= */
let coinImg=null, doorImg=null, ledgeImg=null, platformImg=null, platformRailImg=null;
let terminalFrame1=null, terminalFrame2=null;

async function loadTiles(){
  try {
    coinImg     = await IMG(SPRITE_DEF.coin);
    doorImg     = await IMG(SPRITE_DEF.door);
    ledgeImg    = await IMG(SPRITE_DEF.ledge);
    platformImg = await IMG(SPRITE_DEF.platform);
    platformRailImg = await IMG(`assets/platform_rail.png?${HYPER_RELOAD_TAG}`);
    terminalFrame1 = await IMG(`assets/hacker_terminal_frame1.png?${HYPER_RELOAD_TAG}`);
    terminalFrame2 = await IMG(`assets/hacker_terminal_frame2.png?${HYPER_RELOAD_TAG}`);
  } catch (error) { console.error('Error loading tiles:', error); }
}

function cull(){ const cutoff=cameraX-300;
  for(let i=ads.length-1;i>=0;i--) if(ads[i].x+160<cutoff) ads.splice(i,1);
  for(let i=robots.length-1;i>=0;i--) if(robots[i].x+120<cutoff) robots.splice(i,1);
  for(let i=drones.length-1;i>=0;i--) if(drones[i].x+120<cutoff) drones.splice(i,1);
  for(let i=coins.length-1;i>=0;i--) if(coins[i].x+40<cutoff) coins.splice(i,1);
  for(let i=females.length-1;i>=0;i--) if(females[i].x+120<cutoff) females.splice(i,1);
}
function activateEnemies(){
  const visRight = cameraX + VW + 64;
  const lvl = getLevel();
  for(const r of robots){
    if(!r.active && r.x<visRight){
      if(lvl===1){ if(player.x >= 900){ r.active=true; } } else { r.active=true; }
    }
  }
  for(const d of drones){ if(!d.active && d.x<visRight){ if(lvl>=2) d.active=true; } }
}

/* === L2 CONES === */
function drawDronesAndCones(now){
  if(getLevel()<2) return;
  for(const d of drones){
    const x=(d.x-cameraX)|0, y=d.y|0; if(x+32<0||x>VW) continue;
    const coneH = 120, baseW = 70;
    const topX = x + 8, topY = y + 10, by = Math.min(VH-10, topY + coneH);
    ctx.save();
    const grad = ctx.createLinearGradient(topX, topY, topX, by);
    grad.addColorStop(0, 'rgba(111,194,255,0.30)');
    grad.addColorStop(1, 'rgba(111,194,255,0.02)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(topX, topY);
    ctx.lineTo(topX + baseW/2, by);
    ctx.lineTo(topX - baseW/2, by);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}
function playerLitByCone(){
  if(getLevel()<2 || !drones.length) return false;
  const px = player.x + player.w/2, py = player.y + player.h/2;
  for(const d of drones){
    const topXw = d.x + 8, topYw = d.y + 10;
    if(py < topYw) continue;
    const coneH = 120, baseW = 70;
    const t = Math.min(1, (py - topYw) / coneH);
    const halfAtY = (baseW/2) * t;
    if (Math.abs(px - topXw) <= halfAtY) return true;
  }
  return false;
}

/* ================= UPDATE LOOP ================= */
function update(dt,now){
  if(endMode){ return; } // end screen mode

  if(gameState!=='playing') return;

  for(const t of terminals){ if(t.cooldown>0) t.cooldown=Math.max(0,t.cooldown-dt); }

  const L=!!keys['ArrowLeft'], R=!!keys['ArrowRight'];
  const accel=player.onGround?player.aGround:player.aAir;
  const drag=player.onGround?player.dragG:player.dragA;
  if(L){ player.vx=Math.max(player.vx-accel,-player.speed); player.facing=-1; }
  if(R){ player.vx=Math.min(player.vx+accel, player.speed);  player.facing= 1; }
  if(!L && !R) player.vx*=drag;

  if(player.onGround) coyoteUntil=now+COYOTE;
  const wantsJump = now<=jumpBufferUntil;
  if(wantsJump && (player.onGround || now<=coyoteUntil)){ player.vy=-player.jump; player.onGround=false; jumpBufferUntil=0; coyoteUntil=0; }
  if(!jumpHeld && player.vy<-1.25) player.vy=-1.25;

  player.vy+=.18; if(player.vy>3.7) player.vy=3.7;

  collide(player);
  pickupCoins();

  if(player.hp<=0) setAnim(player,'player','dead',true);
  else if(now<player.hitUntil) setAnim(player,'player','hurt',true);
  else if(!player.onGround) setAnim(player,'player', player.vy<0?'jump':'fall');
  else { const s=Math.abs(player.vx); setAnim(player,'player', s>1.05?'run':(s>0.2?'walk':'idle')); }
  stepAnim(player,dt);

  const need=cameraX+VW+CHUNK*2; while(generatedUntil<need) genChunk(generatedUntil);

  activateEnemies();
  const hacked = now<hackUntil;

  // drones movement
  for(const d of drones){
    if(!d.active || d.disabled) continue;
    if(!hacked){
      d.x+=d.dir*d.speed; d.phase=(d.phase||0)+.02; d.y+=Math.sin(d.phase)*.2;
      if((d.x%CHUNK)<8||(d.x%CHUNK)>CHUNK-8) d.dir*=-1;
    }
  }

  // robots AI (+lit jump on L2)
  const lit = (getLevel()===2) ? playerLitByCone() : false;

  for(const r of robots){
    if(!r.active) continue;
    const dx = player.x - r.x;
    const dy = player.y - r.y;
    const see = Math.abs(dx) < 92 && Math.abs(dy) < 56;

    const playerAbove = (player.y + player.h) < (r.y - 6);
    let hasFloorBetween = false;
    if(playerAbove){
      for(const p of platforms){
        const betweenY = (p.y >= player.y) && (p.y <= r.y);
        const overlapX = (r.x > p.x - 8) && (r.x < p.x + p.w + 8);
        if(betweenY && overlapX){ hasFloorBetween = true; break; }
      }
    }

    if(see && !(playerAbove && hasFloorBetween)){
      r.state='chase'; r.alert=true; r.dir = dx > 0 ? 1 : -1; r.x += r.dir * r.speed * 1.25;
    } else if(playerAbove){
      if(r.state!=='search'){
        r.state='search'; r.alert=false; r.searchUntil=now+2500+Math.random()*2000;
        const offset = (dx > 0 ? -1 : 1) * (24 + Math.random()*28);
        const c = r.x + offset, span = 28 + Math.random()*18;
        r.patrolL=c - span; r.patrolR=c + span; r.dir = Math.random()<.5?-1:1; r.lookTimer = now + 600 + Math.random()*800;
      }
      if(now > r.lookTimer){ r.dir *= -1; r.lookTimer = now + 600 + Math.random()*900; }
      r.x += r.dir * r.speed * 0.9;
      if(r.x < r.patrolL){ r.x = r.patrolL; r.dir = 1; }
      if(r.x > r.patrolR){ r.x = r.patrolR; r.dir = -1; }
      if (getLevel()===2 && lit){ r.y -= 0.9; }
      if(now > r.searchUntil) r.state='patrol';
    } else {
      r.alert=false;
      if(r.state!=='patrol'){ r.state='patrol'; r.patrolL=r.x-40; r.patrolR=r.x+40; r.dir = Math.sign(dx)||1; }
      r.x += r.dir * r.speed;
      if(r.x < r.patrolL){ r.x = r.patrolL; r.dir = 1; }
      if(r.x > r.patrolR){ r.x = r.patrolR; r.dir = -1; }
    }

    setAnim(r,'robot', r.state==='chase' ? 'run' : 'walk'); stepAnim(r,dt);

    if(rects(player,r)){
      if(player.vy>0 && player.y+player.h<=r.y+6){ r.hp--; r.hitUntil=now+120; player.vy=-2.6; score+=12; }
      else if(now > player.hitUntil){
        player.hitUntil = now + 800; // i-frames
        player.vx+=(player.x<r.x)?-0.8:0.8;
        const damage = player.upgrades?.armor ? 5 : 7;
        applyDamage(damage);
      }
    }
  }
  for(let i=robots.length-1;i>=0;i--) if(robots[i].hp<=0) robots.splice(i,1);

  // Level 3 females
  if(getLevel()===3){
    for(const f of females){
      if(f.hasTaken){ setAnim(f,'female','idle'); stepAnim(f,dt); continue; }
      const dir = (player.x > f.x) ? 1 : -1;
      f.x += dir * f.speed;
      setAnim(f,'female','run'); stepAnim(f,dt);
      if(rects(player,f)){
        const take = Math.min(5, btc);
        if(take>0){ btc -= take; }
        f.hasTaken = true;
        setAnim(f,'female','idle');
      }
    }
  }

  if(exitDoor && rects(player, exitDoor)){
    gameState='levelComplete';
    setTimeout(()=>{ 
      saveForShop();
      const shopUrl = `${SHOP_URL}?resume=1&btc=${btc}&score=${score}&level=${level}`;
      window.location.href = shopUrl;
    }, 300);
  }

  updateCamera(); cull();
  player.dist=Math.max(player.dist,player.x);
  const nl=(player.dist/LEVEL_LEN|0)+1; if(nl>level){ level=nl; justLeveled=1200; }
}

/* ================= DRAW ================= */
function drawTiles(){
  const ok = (im)=>im && im.complete && im.naturalWidth>0;
  const img = ok(ledgeImg) ? ledgeImg : (ok(platformImg) ? platformImg : null);

  const RAIL_FRAC   = 0.55;
  const DST_BASE_H  = 20;

  for (const p of platforms){
    const sx = p.x - cameraX; if (sx + p.w < 0 || sx > VW) continue;

    if (!img){
      ctx.fillStyle = '#1a2332'; ctx.fillRect(sx|0, p.y|0, p.w, TILE);
      ctx.fillStyle = '#6fc2ff'; ctx.fillRect(sx|0, p.y|0, p.w, 2);
      ctx.fillStyle = '#4a5568'; ctx.fillRect(sx|0, (p.y+TILE-2)|0, p.w, 2);
      continue;
    }

    const iw = img.naturalWidth, ih = img.naturalHeight;
    const srcBaseY = Math.floor(ih * RAIL_FRAC);
    const srcBaseH = ih - srcBaseY;
    const srcX = 1, srcW = Math.max(1, iw - 2);
    const dy = (p.y - (DST_BASE_H - TILE)) | 0;
    ctx.drawImage(img, srcX, srcBaseY, srcW, srcBaseH, sx|0, dy, p.w, DST_BASE_H);
  }
}
function drawRailsOnTop(){
  const ok = (im)=>im && im.complete && im.naturalWidth>0;
  const img = ok(ledgeImg) ? ledgeImg : null;
  if (!img) return;

  const RAIL_FRAC   = 0.55;
  const DST_BASE_H  = 20;

  const iw = img.naturalWidth, ih = img.naturalHeight;
  const railSrcH = Math.floor(ih * RAIL_FRAC);
  const baseSrcH = ih - railSrcH;
  const scale    = DST_BASE_H / baseSrcH;
  const railDstH = Math.max(10, Math.round(railSrcH * scale));
  const srcX = 1, srcW = Math.max(1, iw - 2);

  for (const p of platforms){
    if (p.y >= VH - TILE) continue;
    const sx = p.x - cameraX; if (sx + p.w < 0 || sx > VW) continue;
    const y  = (p.y - railDstH) | 0;
    ctx.drawImage(img, srcX, 0, srcW, railSrcH, sx|0, y, p.w, railDstH);
  }
}
function drawTerminals(){
  for(const t of terminals){ 
    const x=(t.x-cameraX)|0; if(x+t.w<0||x>VW) continue;

    const hasAnimFrames = terminalFrame1 && terminalFrame1.complete && terminalFrame2 && terminalFrame2.complete;
    let currentTerminalImg = null;
    if(hasAnimFrames) {
      const animSpeed = 300;
      const frameIndex = Math.floor(performance.now() / animSpeed) % 2;
      currentTerminalImg = frameIndex === 0 ? terminalFrame1 : terminalFrame2;
    }

    if(currentTerminalImg && currentTerminalImg.complete && currentTerminalImg.naturalWidth){
      ctx.save();
      if(t.cooldown <= 0) { ctx.shadowColor = '#00ff9d'; ctx.shadowBlur = 4; }
      else { ctx.shadowColor = '#ff4444'; ctx.shadowBlur = 2; }
      ctx.drawImage(currentTerminalImg, x-2, t.y-4, t.w+4, t.h+4);
      ctx.restore();
      if(t.cooldown > 0) {
        ctx.fillStyle = 'rgba(255, 68, 68, 0.8)';
        ctx.fillRect(x, t.y-2, Math.max(1, (t.w * (t.cooldown / 5000))), 2);
      }
    }else{
      ctx.fillStyle = t.cooldown > 0 ? '#6b4d9b' : '#9b6bff'; 
      ctx.fillRect(x,t.y,t.w,t.h);
      ctx.fillStyle = t.cooldown > 0 ? '#ccc' : '#fff'; 
      ctx.fillRect(x+2,t.y+3,t.w-4,3);
      ctx.fillStyle = '#00ff9d'; ctx.font = '6px monospace'; ctx.fillText('HACK', x+1, t.y+t.h-2);
    }
  }
}
function drawCoins(){
  for(const c of coins){
    if(c.taken) continue;
    const x=(c.x-cameraX)|0, y=c.y|0; if(x<-16||x>VW+16) continue;
    if(coinImg && coinImg.complete && coinImg.naturalWidth){
      const coinSize = 20;
      ctx.save(); ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 8;
      ctx.drawImage(coinImg, x-coinSize/2, y-coinSize/2, coinSize, coinSize);
      ctx.restore();
    }else{
      ctx.fillStyle='#ffd95e'; ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='#ffaa00'; ctx.lineWidth=2; ctx.stroke();
      ctx.fillStyle='#000'; ctx.font='8px monospace'; ctx.textAlign='center'; ctx.fillText('₿', x, y+2);
      ctx.textAlign='left';
    }
  }
}
function drawEntities(now){
  for(const r of robots){
    const x=(r.x-cameraX)|0, y=r.y|0; if(x+48<0||x>VW) continue;
    drawAnim(r,'robot',x-14,y-24,(player.x<r.x), now<r.hitUntil?0.75:1);
  }
  for(const d of drones){
    const x=(d.x-cameraX)|0, y=d.y|0; if(x+32<0||x>VW) continue;
    if(!d.anim.runner) setAnim(d,'drone','move');
    stepAnim(d,16); drawAnim(d,'drone',x-7,y-9,false, d.disabled?0.7:1);
  }
  for(const f of females){
    const x=(f.x-cameraX)|0, y=f.y|0; if(x+48<0||x>VW) continue;
    const flip = (player.x < f.x);
    drawAnim(f,'female',x-15,y-20, flip, 1);
  }
  const px=(player.x-cameraX)|0, py=player.y|0;
  drawAnim(player,'player',px-15,py-20, player.facing===-1, performance.now()<player.hitUntil?0.8:1);
}
function drawExitDoor(){
  if(!exitDoor) return;
  const x=(exitDoor.x-cameraX)|0, y=exitDoor.y|0;
  if(x>VW||x+exitDoor.w<0) return;
  if(doorImg && doorImg.complete && doorImg.naturalWidth){
    ctx.save(); ctx.shadowColor = '#ff1493'; ctx.shadowBlur = 6;
    ctx.drawImage(doorImg, x, y, exitDoor.w, exitDoor.h);
    ctx.restore();
  }else{
    ctx.fillStyle='#2a3040'; ctx.fillRect(x,y,exitDoor.w,exitDoor.h); 
    ctx.fillStyle='#6fc2ff'; ctx.fillRect(x+exitDoor.w-6,y+exitDoor.h/2-3,4,6);
    ctx.fillStyle='#8fb3ff'; ctx.fillRect(x+2,y+4,exitDoor.w-4,3);
    ctx.fillStyle='#a0c4ff'; ctx.fillRect(x+2,y+8,exitDoor.w-4,2);
    ctx.fillStyle='#7dff9a'; ctx.fillText('SHOP',x+3,y+exitDoor.h-8); ctx.fillText('DOOR',x+3,y+exitDoor.h-2);
    ctx.strokeStyle='#6fc2ff'; ctx.lineWidth=1; ctx.strokeRect(x,y,exitDoor.w,exitDoor.h);
  }
}

/* Controls hint */
function drawControlsHint() {
  const title = 'Blackout Protocol';
  ctx.font='9px monospace'; ctx.textAlign='left';
  const titleW = ctx.measureText(title).width;
  ctx.fillStyle='#cfd6df'; ctx.fillText(title,6,4);

  const pad = 6;
  const avail = VW - (titleW + pad*2 + 2);

  const candidates = [
    {text:'← → Move | Space | Enter | E(EMP) | ESC', size:7},
    {text:'← → | Space | Enter | E | ESC',           size:7},
    {text:'←→|␣|⏎|E|ESC',                            size:7},
    {text:'←→ ␣ ⏎ E ESC',                            size:6},
  ];

  let choice = candidates[0];
  for (const c of candidates){
    ctx.font = `${c.size}px monospace`;
    if (ctx.measureText(c.text).width <= avail){ choice=c; break; }
  }

  ctx.textAlign='right';
  ctx.fillStyle='#9aa3b2';
  ctx.font = `${choice.size}px monospace`;
  ctx.fillText(choice.text, VW-4, 4);

  ctx.textAlign='left';
  ctx.font='9px monospace';
}
function drawUI(now){
  if(endMode){
    // End screen
    ctx.fillStyle='#000'; ctx.fillRect(0,0,VW,VH);
    drawBackgrounds();
    ctx.fillStyle='rgba(0,0,0,.72)'; ctx.fillRect(0,0,VW,VH);
    ctx.fillStyle='#e8f3ff'; ctx.font='12px monospace';
    const msg='The End. More to be added.'; 
    ctx.fillText(msg, (VW - ctx.measureText(msg).width)/2, VH/2 - 10);
    return;
  }

  ctx.fillStyle='rgba(0,0,0,.78)'; ctx.fillRect(0,0,VW,20);
  drawControlsHint();

  ctx.fillStyle='#fff'; ctx.fillText(`HP:${Math.max(0,player.hp)}  L:${level}  SC:${score}  BTC:${btc}`,6,24);
  ctx.fillStyle='#7dff9a'; ctx.fillText(`DIST:${player.dist|0}  DOOR@:${(LEVEL_LEN-40)|0}`, 6, 36);

  const left=Math.max(0,hackUntil-now)|0;
  if(left>0){ ctx.fillStyle='#7dff9a'; ctx.fillText(`Hack ${Math.ceil(left/1000)}s`,6,48); }
  else if(now<hackCDUntil){ ctx.fillStyle='#7f8a99'; ctx.fillText(`Hack CD ${((hackCDUntil-now)/1000|0)}s`,6,48); }
  else { ctx.fillStyle='#7dff9a'; ctx.fillText('Enter: Hack',6,48); }

  const charges = (player.upgrades?.mobileEMPCharges|0);
  if (player.upgrades?.mobileEMP === true && charges>0){
    ctx.fillStyle='#a0ffea'; ctx.fillText(`EMP Charges: ${charges} (E)`, VW-120, 24);
  }

  if(gameState==='paused'){ ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,VW,VH); ctx.fillStyle='#fff'; ctx.fillText('PAUSED (ESC)',VW/2-30,VH/2); }
  if(gameState==='levelComplete'){ ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(0,0,VW,VH); ctx.fillStyle='#7dff9a'; ctx.fillText('LEVEL COMPLETE → SHOP',VW/2-60,VH/2-8); }
}

/* ======== HOLOGRAM AD OVERLAY ======== */
function drawOverlay(now){
  octx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  if(endMode) return;

  const vis=[];
  for(const a of ads){
    const sx=Math.round(RENDER.ox+(a.x-cameraX)*RENDER.scale);
    const sy=Math.round(RENDER.oy+a.y*RENDER.scale);
    if(sx>-200 && sx<overlayCanvas.width+200 && sy<overlayCanvas.height*0.85) vis.push({a,sx,sy});
  }
  octx.save();
  for(const {a,sx,sy} of vis){
    a.phase = (a.phase||0) + 0.03;
    const flick = 0.65 + 0.35*Math.sin(a.phase*3);
    const bob   = Math.sin(a.phase)*2*RENDER.scale;
    const tilt  = (Math.sin(a.phase*0.6))*0.03;

    // Pick correct image handle for the current level set
    let img=null;
    if(a.kind==='drink'){
      // Level 1 only: 2-frame blink
      const f = (Math.floor((performance.now()/350))%2===0) ? 'drinkA' : 'drinkB';
      img = CurrentAds.imgObjs[f] || null;
    } else {
      img = CurrentAds.imgObjs[a.kind] || null;
    }
    if(!img) continue;

    const targetW = Math.round(56*RENDER.scale);
    const ratio = img.height ? (img.width/img.height) : 1;
    const w = targetW, h = Math.max(11, Math.round((targetW/ratio)));
    const x = sx - Math.round(w/2), y = sy - Math.round(h/2) + bob;

    octx.globalAlpha = 0.85;
    octx.fillStyle = 'rgba(10,14,20,0.5)';
    octx.fillRect(x-8,y-8,w+16,h+16);
    octx.globalAlpha = 1;
    octx.strokeStyle = `rgba(111,194,255,0.5)`;
    octx.lineWidth = 2;
    octx.strokeRect(x-8,y-8,w+16,h+16);

    octx.save();
    octx.translate(x+w/2, y+h/2);
    octx.rotate(tilt);
    octx.globalAlpha = 0.72 + 0.12*Math.sin(a.phase*2);
    octx.drawImage(img, -w/2, -h/2, w, h);
    octx.globalAlpha = 0.18 * flick;
    octx.shadowColor = '#6fc2ff';
    octx.shadowBlur  = 22;
    octx.drawImage(img, -w/2, -h/2, w, h);
    octx.restore();

    octx.globalAlpha = 0.12*flick;
    octx.fillStyle = '#6fc2ff';
    octx.fillRect(x-8, y + (h*0.2|0), w+16, 1);
    octx.globalAlpha = 1;
  }
  octx.restore();
}

/* ================= BLIT ================= */
function blit(){
  gctx.clearRect(0,0,gameCanvas.width,gameCanvas.height);
  const s=Math.min(gameCanvas.width/VW, gameCanvas.height/VH);
  const sw=(VW*s)|0, sh=(VH*s)|0, ox=((gameCanvas.width-sw)/2)|0, oy=((gameCanvas.height-sh)/2)|0;
  gctx.drawImage(nes,0,0,VW,VH,ox,oy,sw,sh); RENDER={scale:s,ox,oy};
}

/* ================= RESET / BOOT / LOOP ================= */
function placeExitDoor(){
  const x=LEVEL_LEN-40, y=groundY()-DOOR_H;
  exitDoor={x, y, w:DOOR_W, h:DOOR_H};
}
function spawnLevel3Females(){
  females=[];
  const n = 3 + ((Math.random()*3)|0);
  for(let i=0;i<n;i++){
    const x = 180 + i*180 + Math.random()*60;
    females.push({x:x|0, y:VH-TILE*2, w:18, h:28, speed:.5 + Math.random()*0.3, hasTaken:false, anim:{state:'idle',runner:null}});
  }
}
function reset(){
  score=SSgetN('playerScore',0);
  btc  =SSgetN('playerBTC',0);
  level=SSgetN('gameLevel',1);

  startLevel(level);

  gameState='playing'; cameraX=0; worldMaxX=0; justLeveled=0; endMode=false;
  platforms=[]; robots=[]; drones=[]; females=[]; terminals=[]; ads=[]; coins=[]; generatedUntil=0; exitDoor=null;
  player=makePlayer(); setAnim(player,'player','idle');

  if(getLevel()===4){
    endMode=true;
    document.getElementById('endBtn').style.display='block';
    return; // draw loop will render end screen
  }

  for(let x=0;x<CHUNK*4;x+=CHUNK) genChunk(x);
  placeExitDoor();

  if(getLevel()===2){
    drones.push({x:120,y:70,w:18,h:14,dir:1,speed:.7,phase:Math.random()*6,active:true,disabled:false,anim:{state:'move',runner:null}});
    drones.push({x:220,y:85,w:18,h:14,dir:-1,speed:.7,phase:Math.random()*6,active:true,disabled:false,anim:{state:'move',runner:null}});
  }
  if(getLevel()===3) spawnLevel3Females();

  document.getElementById('resetBtn').style.display='none';
  document.getElementById('endBtn').style.display='none';
}
function startOverFresh(){
  try { sessionStorage.clear(); } catch {}
  sessionStorage.setItem('bp_session_started','1');
  SSsetN('gameLevel', 1);
  SSsetN('playerBTC', 0);
  SSsetN('playerScore', 0);
  SSsetO('playerUpgrades', {});
  SSsetN('playerHealth', 100);
  location.href='index.html?fresh=1';
}

async function assetSelfTest(){
  try{
    const urls=[]; const push=(u)=>u&&urls.push(u);
    ['player','robot','drone','female'].forEach(k=>{
      const o=SPRITE_DEF[k]; if(o&&o.states) Object.values(o.states).forEach(push);
    });
    ['bg_far','bg_near','coin','door','ledge','platform'].forEach(k=>push(SPRITE_DEF[k]));
    Object.values(adConfigForLevel(getLevel()).images||{}).forEach(push);
    ['assets/hacker_terminal_frame1.png','assets/hacker_terminal_frame2.png'].forEach(u=>push(`${u}?${HYPER_RELOAD_TAG}`));
    const head=async u=>{ try{ const r=await fetch(u,{method:'HEAD',cache:'no-store'}); return {u,ok:r.ok,st:r.status}; }catch{ return {u,ok:false,st:'net'}; } };
    const results=await Promise.all(urls.filter(Boolean).map(head));
    const bad=results.filter(r=>!r.ok);
    if(bad.length){
      console.group('%cMissing/blocked assets','color:#ffb36a');
      bad.forEach(b=>console.warn(b.st,b.u));
      console.groupEnd();
      window.__ASSET_ERRORS__=bad.map(b=>b.u);
    }else{
      console.info('All assets resolved (HEAD ok).');
      window.__ASSET_ERRORS__=[];
    }
  }catch(e){ console.warn('Asset self-test failed',e); }
}

async function boot(){
  try{
    setBackgroundsForLevel(getLevel());
    SPR = await loadSprites(SPRITE_DEF);
    await Promise.all([loadBackgrounds(), loadTiles(), loadAdImagesForLevel(getLevel())]);
    await assetSelfTest();
    reset();
    READY=true;
  }catch(err){ console.error(err); LOAD_MSG='Load failed (check console)'; }
}
boot();

function loop(now){
  const dt = loop.t ? now - loop.t : 16; loop.t = now;
  if (!READY){
    ctx.fillStyle='#000'; ctx.fillRect(0,0,VW,VH);
    drawSky(); ctx.fillStyle='#cfd6df'; ctx.fillText(LOAD_MSG, VW/2 - 20, VH/2);
    blit(); requestAnimationFrame(loop); return;
  }

  if (!endMode && gameState==='playing') update(dt, now);

  ctx.fillStyle='#000'; ctx.fillRect(0,0,VW,VH);
  drawBackgrounds();
  if(!endMode){
    drawTiles(); drawTerminals(); drawDronesAndCones(now); drawCoins(); drawExitDoor(); drawEntities(now); drawRailsOnTop(); 
  }
  drawUI(now);
  blit(); drawOverlay(now);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>

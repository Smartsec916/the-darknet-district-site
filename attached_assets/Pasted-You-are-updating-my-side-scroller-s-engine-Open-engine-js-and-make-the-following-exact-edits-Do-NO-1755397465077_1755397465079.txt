You are updating my side-scroller’s engine. Open engine.js and make the following exact edits. Do NOT create new files. Do NOT duplicate let/const names. Keep styles and other logic unchanged.

GOAL
- Level 3 has ONLY Female NPCs (no robots).
- Each Female NPC moves like a robot patrol.
- On first overlap with the player, drain exactly 3 BTC (or the remainder if <3), then permanently ignore the player.
- BTC lives in sessionStorage under key "btc".
- If Level 3 has no female NPC spawns defined, inject 2–3 safe defaults so they appear.

EDITS

1) Add this class to engine.js (place it near other entity classes). Avoid duplicate declarations.
----------------------------------------------------------------
class FemaleNPC {
  constructor(def, assets, world, playerRef) {
    this.x = def.x;
    this.y = def.y;
    this.w = def.w ?? 32;
    this.h = def.h ?? 48;

    this.dir   = def.dir ?? -1;         // -1 left, +1 right
    this.speed = def.speed ?? 1.0;
    this.minX  = def.minX ?? (this.x - 64);
    this.maxX  = def.maxX ?? (this.x + 64);

    this.vx = 0;
    this.vy = 0;
    this.hasDrained = false;

    this.assets = assets;   // expects assets.img.female_idle / female_run
    this.world  = world;    // expects { gravity, slide(...) }
    this.playerRef = playerRef;
  }

  static loadAssets(loader) {
    // Use the same loader your engine uses for other sprites.
    if (loader && typeof loader.image === 'function') {
      loader.image('female_idle','./assets/female_idle.png');
      loader.image('female_run','./assets/female_run.png');
    } else {
      // If your engine preloads differently, make sure assets.img has these by the time draw() runs.
    }
  }

  get bbox() { return { x:this.x, y:this.y, w:this.w, h:this.h }; }

  update(dt) {
    // Patrol logic like robots
    if (this.x <= this.minX) this.dir = 1;
    if (this.x >= this.maxX) this.dir = -1;
    this.vx = this.dir * this.speed;

    // Gravity + tile collision (mirror robot’s physics)
    this.vy += (this.world.gravity ?? 2000) * dt;
    const n = this.world.slide(this.x, this.y, this.w, this.h, this.vx, this.vy);
    this.x = n.x; this.y = n.y;

    // One-time BTC drain
    const p = this.playerRef && this.playerRef();
    if (!this.hasDrained && p && this._overlap(this.bbox, p.bbox)) {
      const current = parseInt(sessionStorage.getItem('btc') || '0', 10);
      const taken = Math.min(3, current);
      sessionStorage.setItem('btc', String(current - taken));
      this.hasDrained = true; // permanently ignore after first drain
    }
  }

  draw(ctx) {
    const run = Math.abs(this.vx) > 0.1;
    const img = run ? (this.assets.img && this.assets.img.female_run) 
                    : (this.assets.img && this.assets.img.female_idle);
    if (!img) return;

    // Face travel direction (optional horizontal flip)
    ctx.save();
    const flip = this.dir < 0;
    if (flip) {
      ctx.translate(Math.floor(this.x)+this.w, Math.floor(this.y));
      ctx.scale(-1, 1);
      ctx.drawImage(img, 0, 0, this.w, this.h);
    } else {
      ctx.drawImage(img, Math.floor(this.x), Math.floor(this.y), this.w, this.h);
    }
    ctx.restore();
  }

  _overlap(a,b){
    return a && b && a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }
}
----------------------------------------------------------------

2) In your global/preload phase (where robots/images are preloaded), call:
----------------------------------------------------------------
FemaleNPC.loadAssets(loader);
----------------------------------------------------------------
(If your engine doesn’t have a `loader` object, ensure `assets.img.female_idle` and `assets.img.female_run` are loaded the same way other sprites are. Keep filenames as shown.)

3) In the entity factory/switch that spawns entities from level defs, add:
----------------------------------------------------------------
case 'female_npc':
  return new FemaleNPC(def, ctx.assets, ctx.world, () => ctx.player);
----------------------------------------------------------------

4) Ensure Level 3 has NO robots and DOES have female NPCs:
In the function that builds a level from its data (right after you obtain `level`/`defs` and before you instantiate entities), insert this guard:

----------------------------------------------------------------
// Helper to detect current level id from param or sessionStorage
function _isLevel3(levelId) {
  if (levelId === 3) return true;
  try {
    const g = parseInt(sessionStorage.getItem('gameLevel') || '0', 10);
    if (g === 3) return true;
  } catch (_) {}
  return false;
}

// Call this right after you have the level object/defs for the level being loaded:
if (_isLevel3(levelId)) {
  // Remove any robots on Level 3
  if (Array.isArray(level.defs)) {
    level.defs = level.defs.filter(d => d.type !== 'robot');
  } else {
    level.defs = [];
  }

  // If no female_npc entries are present, inject a few defaults that patrol on flat ground:
  if (!level.defs.some(d => d.type === 'female_npc')) {
    level.defs.push(
      { type:'female_npc', x: 280, y: 560, w:32, h:48, speed:1.0, dir:-1, minX:240, maxX:360 },
      { type:'female_npc', x: 520, y: 560, w:32, h:48, speed:1.0, dir: 1, minX:480, maxX:600 },
      { type:'female_npc', x: 760, y: 560, w:32, h:48, speed:1.2, dir:-1, minX:720, maxX:840 },
    );
  }
}
----------------------------------------------------------------

5) Make sure the spawn pipeline already pushes recognized entities (including 'female_npc') into the same update/draw arrays as robots. Do not create new arrays—reuse the existing actor list to avoid duplicate let/const errors.

6) Ensure these images exist and are transparent PNGs:
- ./assets/female_idle.png
- ./assets/female_run.png
(If your sprite sizes differ, adjust w/h in the defs above.)

CONSTRAINTS
- Do not duplicate variable declarations (no second `let/const` for names that already exist).
- Do not change unrelated logic, physics, or UI.
- No robots should be present on Level 3 after this change.
- Each Female NPC drains BTC exactly once per NPC.

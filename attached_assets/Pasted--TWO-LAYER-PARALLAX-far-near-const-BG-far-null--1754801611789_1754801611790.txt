/* === TWO-LAYER PARALLAX (far + near) =============================== */

const BG = {
  far: null, near: null,
  farW: 0,   nearW: 0
};

// Parallax multipliers (smaller = slower)
const PARALLAX = { far: 0.25, near: 0.90 };

// Optional: fade the top of the near layer into transparency
// so far skyline shows through. Increase px for a taller fade.
const NEAR_FADE_PX = 160;

// Preload helper
function loadImg(src) {
  return new Promise((res, rej) => {
    const i = new Image();
    i.onload = () => res(i);
    i.onerror = rej;
    i.src = src;
  });
}

// Call once at boot
async function loadBackgrounds() {
  try {
    BG.far  = await loadImg('assets/01_bg_far.png');
    BG.near = await loadImg('assets/01_bg_near.png');
    BG.farW  = BG.far.width;
    BG.nearW = BG.near.width;
    console.log('BG loaded:', { far: BG.farW, near: BG.nearW });
  } catch (e) {
    console.warn('BG load error', e);
  }
}

// Tiles an image seamlessly across the screen at y,
// scrolled by cameraX*speed. alpha is optional.
function tileLayer(img, imgW, speed, y, alpha = 1) {
  if (!img) return;
  ctx.save();
  ctx.globalAlpha = alpha;

  // cameraX should be your world/camera position in pixels
  const cam = cameraX || 0;
  let x = -((cam * speed) % imgW);
  if (x > 0) x -= imgW;

  for (let i = 0; i < 3; i++) {
    ctx.drawImage(img, Math.floor(x + i * imgW), Math.floor(y));
  }
  ctx.restore();
}

// Draw backgrounds (call near the start of your frame)
function drawBackgrounds() {
  if (!BG.far || !BG.near) return;

  // Far skyline: draw from the top of the canvas
  tileLayer(BG.far, BG.farW, PARALLAX.far, 0, 1);

  // Near containers: align their *bottom* to the canvas bottom
  const nearY = canvas.height - BG.near.height;

  // Draw near layer, then punch a vertical alpha fade at the top
  ctx.save();
  tileLayer(BG.near, BG.nearW, PARALLAX.near, nearY, 1);

  // Fade mask (top of near layer -> transparent)
  const fadeTop = Math.max(nearY, nearY);
  const fadeH   = Math.min(NEAR_FADE_PX, BG.near.height);
  const g = ctx.createLinearGradient(0, fadeTop, 0, fadeTop + fadeH);
  g.addColorStop(0, 'rgba(0,0,0,0)');  // fully transparent at the very top
  g.addColorStop(1, 'rgba(0,0,0,1)');  // fully opaque by fade end

  ctx.globalCompositeOperation = 'destination-in';
  ctx.fillStyle = g;
  ctx.fillRect(0, nearY, canvas.width, BG.near.height);
  ctx.restore();
}

/* === INTEGRATION NOTES =============================================

1) Make sure you call loadBackgrounds() once during init:
   initGame() { ...; loadBackgrounds(); ... }

2) In your main draw/update loop, call drawBackgrounds() *before*
   drawing platforms, player, enemies, etc.

3) Remove/disable any other background code (mid layers, ads-as-BG, etc.)
   so only these two run.

4) If you see a visible seam on either layer, confirm the PNGs are truly
   tileable left/right. (We can auto-mirror-tile as a fallback if needed.)

5) Tweak parallax feel:
   - Make PARALLAX.near smaller (e.g., 0.75) to reduce “slip”.
   - Make PARALLAX.far smaller (e.g., 0.20) for slower distant motion.

==================================================================== */
